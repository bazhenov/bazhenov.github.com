<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ru" lang="ru-ru">
<head>
	 <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
	 <meta http-equiv="content-type" content="text/html; charset=utf-8" />
	 <title>Deploy и прочие неприятности</title>
	 <meta name="author" content="Denis Bazhenov" />
	 <link href="http://feeds.feedburner.com/severe-reality" rel="alternate" title="Severe Reality" type="application/atom+xml" />

	 <link href='http://fonts.googleapis.com/css?family=Open+Sans:300,400,600&subset=latin,cyrillic-ext,cyrillic' rel='stylesheet' type='text/css'>
	 <!-- syntax highlighting CSS -->
	 <link rel="stylesheet" href="/css/syntax.css" type="text/css" />

	 <!-- Homepage CSS -->
	 <link rel="stylesheet" href="/css/screen.css" type="text/css" media="screen, projection" />
	 <link rel="stylesheet" href="http://yandex.st/highlightjs/6.1/styles/idea.min.css">

	<script src="http://code.jquery.com/jquery-1.7.1.min.js"></script>
</head>
<body>

	<div class="site">
		
			<header>
				<div class="content">
					<a href="/">Суровая реальность</a>
				</div>
			</header>
		

		<div class="post content">
	<h1>Deploy и прочие неприятности</h1>
	<div class="meta">
		<span class="date">10 June 2011</span>
		<span class="tags">
			
				<a href="/tags.html#deploy">deploy</a>
			
				<a href="/tags.html#jetty">jetty</a>
			
				<a href="/tags.html#java">java</a>
			
				<a href="/tags.html#continuous integration">continuous integration</a>
			
		</span>
		
	</div>
	
	
	<p>В продолжение <a href="/blog/2011/04/09/build.html">предыдущего поста</a> хочу немного рассказать о том как у нас происходит deploy. В прошлый раз мы закончили на том что артефакт доставлен на production и готов к развертыванию. Начинается самое интересное, процесс деплоя.</p>

<!--excerpt-->

<p>Но для начала надо немного описать платформу на которую мы деплоим наши приложения. В качестве servlet-container&rsquo;а мы используем <a href="http://jetty.codehaus.org/jetty/">Jetty</a>. Есть два основных типа приложений, которые мы пишем и сопровождаем: web-приложения, которые имеют некий web-интерфейс (это может быть как UI, так и REST интерфейс), а также background сервисы, которые как правило работают асинхронно (мы активно используем <a href="http://activemq.apache.org/">ActiveMQ</a>). И здесь нужно подметить первую особенность, мы используем Jetty для обоих типов приложений. Это может показатся странным, так как для background-сервисов мы получаем явный overhead связанный с запуском и работой servlet-container&rsquo;а. Но этот overhead просто мизерный по сравнению с тем какие плюсы мы получаем. А именно:</p>

<ul>
  <li>единые утилиты управления lifecycle&rsquo;ом приложения вне зависимости от его типа (старт, останов, перезапуск);</li>
  <li>стандартные способы задания конфигурации приложения вне зависимости от его типа;</li>
  <li>стандартные форматы распространения приложения вне зависимости от его типа (в нашем случае <code>.war</code>).</li>
</ul>

<p>Вобщем, стандартизация на лицо.</p>

<p>У нас своя сборка Jetty в которой кроме самого Jetty, есть еще несколько часто используемых нами библиотек (например: <code>slf4j</code>, <code>logback</code>, <code>mysql</code> драйвер, библиотеки connection pooling&rsquo;а и некоторые другие). Сборка представлена в виде rpm пакета, что позволяет очень быстро подготавливать новую машину: <code>yum install jdk jetty</code>, готово.</p>

<p>Вас может удивило почему мы ставим на production машины JDK, а не JRE. Это связано с наличием в JDK очень полезных для диагностики утилит, таких как: <code>jmap</code>, <code>jstack</code>, <code>jvisualvm</code> и других. Это выгодно отличает платформу Java от множества других, &ndash; масса утилит для диагностики, которые в большинстве случаев позволяют довольно быстро понять что не так с приложением.</p>

<p>Деплой приложения состоит из следующих шагов:</p>

<ul>
  <li>распространение бинарника с приложением, а также конфигурации на целевые машины;</li>
  <li>перезапуск servlet container&rsquo;а;</li>
  <li>deployment тестирование.</li>
</ul>

<p>Естественно второй и третий шаг выполняются для всех машин по очереди.</p>

<h2 id="section">Распространение артефакта и конфигурации</h2>
<p>Тут все просто, <code>scp</code> доставляет файлы на каждую машину по очереди и ложит каждый в нужное место. Доставляются артефакты, а также конфигурационные файлы.</p>

<h3 id="servlet-container">Перезапуск servlet container&rsquo;а</h3>
<p>Мы не используем hot redeploy, так как он вызывает ряд проблем. В частности, небезизвестную <a href="http://www.jroller.com/agileanswers/entry/preventing_java_s_java_lang">OutOfMemoryError: PermGen</a>. Для перезапуска используются скрипты входящие в стандартную поставку Jetty с некоторыми несущественными дополнениями.</p>

<h3 id="deployment-">Deployment тестирование</h3>
<p>Этот момент стоит описать поподробнее. После того как Jetty запустился было бы неплохо проверить что приложение способно выполнять основные функции. Тот кто деплоит приложение может опечататься в конфигурации, системные администраторы могут забыть &ldquo;пропилить дырку&rdquo; в firewall&rsquo;е для необходимого приложению сервиса, мало ли что еще может произойти.</p>

<p>Задача deployment тестирования проверить что у приложения есть доступ ко всем необходимым сервисам для того чтобы оно выполняло свою работу. Это могут быть базы данных, очереди сообщений, сетевые файловые системы и другое middleware ПО. К счастью для нас, Spring Beans контейнер практически все делает за нас. Если во время инициализации контейнера (частью которого являются подключения к БД и т.д.) происходит ошибка, об этом легко узнать послав <code>GET</code> запрос на любой url, который обрабатывается непосредственно spring&rsquo;ом. У нас есть соглашение что url <code>/status</code> не занимается приложением и служит для deployment тестирования. Этот url также сообщает какая версия приложения запушена в данный момент. Таким образом, deploy скрипт после того как перезапускает servlet container начинает опрашивать приложение. Если приложение возвращает 200-й статус код, то можно переходить к обновлению следующей машины. Если нет, то процесс деплоя считается неуспешным и прерывается. Тот кто делает deploy может инициировать процедуру отката. Откат мы делаем руками, так как процент &ldquo;битых&rdquo; релизов у нас не велик и смысла автоматизировать эту процедуру пока что смысла нет.</p>

<h3 id="rollout--">Rollout распределенных приложений</h3>
<p>Когда приложение запущено в нескольких экземплярах (на нескольких машинах), то после запуска приложения на одном ноде имеет смысл немного подождать прежде чем переходить к следующей машине. Здесь играют свою роль как особенности приложения, так и особенности платформы. Java, как русские &ndash; &ldquo;долго запрягает, но быстро едет&rdquo; (начальная загрузка байт кода, создание пула соединений, JIT компилятор etc). Нас такой tradeoff вполне устраивает, поэтому наш deploy скрипт может быть сконфигурирован таким образом, чтобы давать только что запущенному ноду &ldquo;разогреться&rdquo; перед тем как принять на себя нагрузку его еще не обновленных коллег. Как правило, 3-5 секунд достаточно.</p>

<p>Деплой на несколько машин (особенно учитывая их &ldquo;разогрев&rdquo;) порождает интересную проблему. Во время обновления кластера, на нем работает <em>две версии приложения</em>. Некоторых людей этот факт ставит в ступор. Они не могут ужиться с тем, что у приложения в любой момент времени нет строго определенной версии.</p>

<p>Суровая реальность заключается в том, что требование работать одновременно в &ldquo;нескольких версиях&rdquo; порождается природой web-приложений. Мы стремимся к тому чтобы наше система всегда была online. Это имеет одно очень важное последствие для процесса deploy&rsquo;я:</p>

<blockquote>
  <p>Мы всегда должны иметь возможность откатиться на предыдущую версию системы, так как пусть редко, но бывает что ошибка все же проходит сквозь все рубежи тестирования и попадает на production. Причем rollback должен осуществлятся не медленнее чем rollout.</p>
</blockquote>

<p>Это приводит нас к следующему заключению: <em>следующая версия системы всегда должна быть обратно-совместима с предыдущей</em>. Это касается не только кода, но и схемы БД, данных в кеше и т.д.</p>

<p>Оказывается, что когда новая версия системы обратно совместима с текущей, нет ничего страшного в том чтобы некоторое время они поработали вместе.</p>

<h2 id="section-1">На практике</h2>
<p>Итак, как это все происходит на практике. Разработчик заходит через <code>ssh</code> на машину-координатор, куда автоматически доставляются артефакты приложений. У каждого приложения есть отдельная директория содержимое которой выглядит примерно следующим образом:</p>

<pre class="shell"><code>-rw-rw-r-- 1 tech tech      101 Jun 24 16:42 .config
-rw-rw-r-- 1 tech tech     1134 Jun  9 13:05 config.properties
-rw-r--r-- 1 tech tech      163 May 16 16:11 .jettyrc
-rw-r--r-- 1 tech tech 30298960 Jun  3 19:41 search-web-frontend-1.0.118.war
-rw-r--r-- 1 tech tech 30299011 Jun  3 21:25 search-web-frontend-1.0.119.war
-rw-r--r-- 1 tech tech 30298949 Jun 13 21:51 search-web-frontend-1.0.120.war
-rw-r--r-- 1 tech tech 30297647 Jun 14 12:38 search-web-frontend-1.0.121.war
-rw-r--r-- 1 tech tech 30297689 Jun 15 11:50 search-web-frontend-1.0.122.war
-rw-r--r-- 1 tech tech 30298356 Jun 15 12:13 search-web-frontend-1.0.123.war
-rw-r--r-- 1 tech tech 30298678 Jun 15 12:32 search-web-frontend-1.0.124.war
-rw-r--r-- 1 tech tech 30732203 Jun 23 11:45 search-web-frontend-1.0.125.war
-rw-r--r-- 1 tech tech 30732204 Jun 23 11:55 search-web-frontend-1.0.126.war
</code></pre>

<p>Здесь есть несколько файлов о которых стоит рассказать поподробнее. Файл <code>.config</code> это обыкновенный <code>ini</code>-файл хранящий имена всех машин на которых установлено приложение, а также некоторые другие настройки развертывания. <code>config.properties</code> — это <code>properties</code>-файл, который содержит настройки приложения. <code>.jettyrc</code> содержит startup опции виртуальной машины на которой стартует Jetty.</p>

<p>За довольно длительное время мы перепробовали различные способы работы с конфигурационными файлами приложений. Мы хранили их в development системе контроля версий. Мы создавали для них отдельный репозиторий в зоне production. Текущая схема нам нравится больше всего. Она позволяет автоматически бекапить все конфигурационные файлы приложений, что безусловно необходимо, а также не связываться с излишей сложностью VCS систем для управления &ldquo;двумя файлами из 10 строчек каждый&rdquo;.</p>

<p>Если запустить команду deploy без аргументов, то она выведет текущее состояние нодов:</p>

<pre class="shell"><code>$ deploy 
http://search-service1:8080 - Ok com.farpost.search:search-web-frontend 1.0.126
http://search-service2:8080 - Ok com.farpost.search:search-web-frontend 1.0.126
http://search-service3:8080 - Ok com.farpost.search:search-web-frontend 1.0.126
</code></pre>

<p>Благодаря <a href="http://maven.apache.org/">maven</a> во все наши сборки автоматически попадает информация о версии, а также номере билда.</p>

<p>Если же передать команде deploy имя артефакта, то начнется его развертывание на production машинах.</p>

<h2 id="section-2">Дальнейшие соображения</h2>
<p>Текущий процесс нас вполне устраивает, тем не менее у нас есть идеи как сделать его еще лучше.</p>

<h3 id="runtime---">Runtime обновление конфигурации логгирования</h3>
<p>Мы используем <a href="http://logback.qos.ch/">logback</a> в качестве библиотеки логгирования. Существенным ее плюсом является то что она позволяет <a href="http://logback.qos.ch/manual/configuration.html#autoScan">менять конфигурацию логгирования на лету</a>. Достаточно просто поменять XML файл с конфигурацией. Было бы неплохо иметь возможность распространять конфигурацию логгирования на машины без перезагрузки самого приложения.</p>

<h3 id="section-3">Дифференцирование конфигурации различных нодов</h3>
<p>В распределенной системе разные ноды могут иметь идентичную сборку, но разную конфигурацию, обуславливающую требуемую разность в их поведении. Сейчас у нас пока что нет возможности задать разную конфигурацию для разных нодов. Учитывая что конфигурация задается в виде <code>properties</code> файлов, сделать такого рода дифференциорание не сложно.</p>

<h3 id="partial-deploy">Partial deploy</h3>
<p>Иногда бывает необходимо обновить не весь кластер, а только один нод из кластера. В будущем, я думаю мы сделаем такую возможность.</p>

<p>Вот пожалуй и все. А как деплоите приложения вы? ;)</p>



	<div class="bar">
		<div class="g-plusone" data-size="medium"></div>
		<a href="https://twitter.com/share" class="twitter-share-button"
			data-url="http://bazhenov.me/blog/2011/06/10/deploy.html"
			data-via="denis_bazhenov" data-lang="en">Tweet</a>

		<a href="https://twitter.com/denis_bazhenov" class="twitter-follow-button"
			data-show-count="false">Follow</a>
	</div>

	<div id="disqus_thread"></div>
	<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

<!-- Google +1 button -->
<script type="text/javascript">
	(function() {
		var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
		po.src = 'https://apis.google.com/js/plusone.js';
		var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
	})();
</script>

<!-- Twitter buttons -->
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>

<!-- Disqus -->
<script type="text/javascript">
	/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
	var disqus_shortname='severe-reality';
	var disqus_developer=true;

	/* * * DON'T EDIT BELOW THIS LINE * * */
	(function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>

		<footer>
			<div class="content">
				<a href="http://feeds.feedburner.com/severe-reality">RSS Subscribe</a>
					|
				<a href="mailto:dotsid@gmail.com">Email</a>
			</div>
		</footer>
					
	</div>

	<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
	
	<script src="http://yandex.st/highlightjs/6.1/highlight.min.js"></script>
	<script>
	$(document).ready(function() {
		$('pre.code code').each(function(i, e) {hljs.highlightBlock(e, '  ')});
	});
	</script>
	<script type="text/javascript">
		MathJax.Hub.Config({
			tex2jax: {
				inlineMath: [['$','$'], ['\\(','\\)']],
				processEscapes: true
			}
		});
	</script>
	
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-31484732-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</body>
</html>