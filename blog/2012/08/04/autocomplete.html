<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ru" lang="ru-ru">
<head>
	 <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
	 <meta http-equiv="content-type" content="text/html; charset=utf-8" />
	 <title>Толерантный автокомплит</title>
	 <meta name="author" content="Denis Bazhenov" />
	 <link href="http://feeds.feedburner.com/severe-reality" rel="alternate" title="Severe Reality" type="application/atom+xml" />
	 <link href='http://fonts.googleapis.com/css?family=Open+Sans:300,400,600&subset=latin,cyrillic-ext,cyrillic' rel='stylesheet' type='text/css'>
	 
	 <link rel="openid2.provider" href="https://www.google.com/accounts/o8/ud?source=profiles" > 
	 <link rel="openid2.local_id" href="http://www.google.com/profiles/dotsid" >
	 
	 <!-- syntax highlighting CSS -->
	 <link rel="stylesheet" href="/css/syntax.css" type="text/css" />
	 <!-- Homepage CSS -->
	 <link rel="stylesheet" href="/css/screen.css" type="text/css" media="screen, projection" />
	 <link rel="stylesheet" href="http://yandex.st/highlightjs/6.1/styles/idea.min.css">

	<script src="http://code.jquery.com/jquery-1.7.1.min.js"></script>
</head>
<body>

	<div class="site">
		
			<header>
				<div class="content">
					<a href="/">Суровая реальность</a>
				</div>
			</header>
		

		<div class="post content">
	<h1>Толерантный автокомплит</h1>
	<div class="meta">
		<span class="date">04 August 2012</span>
		<span class="tags">
			
				<a href="/tags.html#algorithms">algorithms</a>
			
		</span>
		
	</div>
	
	
	<p>Автокомплит вещь удобная. Он позволяет экономить время на наборе текста, когда множество значений поля закрыто. Хороший автокомплит отличается следующими качествами:</p>

<ul>
  <li>он должен быть быстрый. Если мы хотим экономить силы пользователя, то мы должны ему предложить вариант как можно быстрее;</li>
  <li>он не должен предлагать к вводу варианты которые заведомо неверны;</li>
  <li><em>он должен быть толерантен к пользовательскому вводу</em>. В том числе прощать опечатки.</li>
</ul>

<p>Вот о последнем качестве autocomplete алгоритмов я и хочу сегодня поговорить.</p>

<!-- excerpt -->

<p>Если вы хотите создать приложение толерантное к вводимой пользователем информации, то исправление опечаток в том или ином виде должно быть. Человек может опечататься в первой букве, может попросту не знать как правильно пишется слово. Поэтому, не очень хорошо что первая же неверно введенная пользователем буква приведет к тому что он не сможет выбрать правильный вариант.</p>

<p>Я значительную часть рабочего дня провожу в IntelliJ IDEA. Отличная среда, пожалуй лучшая. А еще, я <a href="/blog/2012/05/12/functional-java.html">использую guava</a>, хорошая библиотека. И есть там такой метод <code>Closeables.closeQuietly()</code>, который закрывает <code>Closeable</code> объект подавляя все исключения. Так вот, когда вы пишете имя метода которого нет в текущем классе, IDEA автоматически предлагает вам сделать <code>static import</code> подходящего метода из других классов.</p>

<p class="image photo"><img src="/images/autocomplete/idea-good.png" alt="IntelliJ IDEA static import" /></p>

<p>Прекрасная фича, которая не работает если вы опечатались. А я ну никак не могу запомнить как правильно пишется слово “quietly”.</p>

<p class="image photo"><img src="/images/autocomplete/idea-bad.png" alt="IntelliJ IDEA static import reject" /></p>

<p>В этом случае IDE “фейлит” и предлагает мне создать новый метод. Примерно то же самое происходит и с автодополнением. Стоит мне ввести хотя бы один не тот символ, как тут же “No suggestions”. Я считаю, IDEA могла бы быть гораздо более толерантна к девелоперу на этапе ввода кода. Это же не какой-нибудь там NetBeans :)</p>

<p>Этой же проблемой страдает большое количество продуктов.</p>

<p class="image photo"><img src="/images/autocomplete/mac-help.png" alt="Mac OS X Help Search" /></p>
<p class="description">Встроенный в Mac OS X поиск по позиция системного меню</p>

<p class="image photo"><img src="/images/autocomplete/mac-spotlight.png" alt="Mac OS X Spotlight Search" /></p>
<p class="description">Mac OS X Spotlight</p>

<p class="image photo"><img src="/images/autocomplete/money.png" alt="Money" /></p>
<p class="description">Money — ПО для учета персональных финансов</p>

<p>Такая ситуация выглядит для меня довольно странно, так как алгоритмы позволяющие разруливать большую часть опечаток при вводе довольно банальны.</p>

<p>Конечно, разработка первоклассного spellchecker’а дело не простое. Оно требует обучения не тривиальных статистических моделей. Но есть несколько простых подходов, которые позволяют в большинстве приложений сделать автокомплит достаточно толерантным, чтобы пользователи были счастливы в 80% случаев.</p>

<h2 id="section">Подход №1: Редакционное расстояние</h2>

<p>Самое простое решение заключается в том чтобы сортировать все позиции словаря по возрастанию редакционного расстояния и показывать только первые несколько позиций. В качестве редакционного расстояния можно взять <a href="http://ru.wikipedia.org/wiki/Расстояние_Левенштейна">расстояние Левенштейна</a>. Расстояние Левенштейна – это минимальное количество операций вставок/удаления/изменения символов необходимое для того чтобы преобразовать исходную строку в целевую.</p>

<blockquote>
  <p>Список слов близких к слову “пазор” и их редакционные расстояния: позор → 1, позер → 2, дозор → 2, помор → 2, побор → 2, подзор → 2, покер → 3, покос → 3.</p>
</blockquote>

<p>Существует статистика что в пределах расстояния Левенштейна 2 находится более 90% опечаток, так что можно показывать только их, чтобы избежать совсем уж неадекватных исправлений.</p>

<h3 id="section-1">Достоинства</h3>

<ul>
  <li>довольно проста в реализации. Имплементацию расчёта расстояния Левенштейна можно найти практически для любого языка программирования.</li>
</ul>

<h3 id="section-2">Недостатки</h3>

<ul>
  <li>Довольно ресурсоемкая. Алгоритмическая сложность алгоритма O(n<sup>2</sup>). Если в вашем словаре много позиций или у вас много посетителей на данное решение может не хватить аппаратных ресурсов.</li>
  <li>в данном виде этот подход не позволяет использовать знания о языковой модели, что не дает корректно исправлять некоторые типичные опечатки. Например опечатка “corola” находится на расстоянии 1 и от “corolla” и от “corona”, соответственно две эти замены будут равновероятны. Но пропуск дублирующей “l” гораздо более вероятная опечатка чем замена “l” на “n”.</li>
</ul>

<p>В целом, решение на основании расстояния Левенштейна будет вполне сносно работать в первом приближении. Его очень просто реализовать, что делает данный подход отличным кандидатом на роль прототипа.</p>

<h2 id="k-gram-">Подход №2: Коэффициент Жаккара и K-gram индекс</h2>

<p>Альтернативный подход заключается в том чтобы использовать <a href="http://ru.wikipedia.org/wiki/Коэффициент_Жаккара">коэффициент Жаккара</a> как метрику расстояния между строками. Коэффициент Жаккара (Jaccard index) это индекс сходства двух множеств который определяется как отношение мощности пересечения этих множеств к мощности их объединения.</p>

<p class="image"><img src="/images/autocomplete/sets.png" alt="Sets" /></p>

<script type="math/tex; mode=display"> J = \frac{\mid A \cap B \mid} {\mid A \cup B \mid} </script>

<p>При коэффициенте Жаккара равном 1 множества равны, при 0 не имеют ни одного общего элемента. Эту метрику можно использовать для оценки близости вводимых пользователем слов к словам из нашего словаря по которому мы делаем autocomplete.</p>

<p>Но для того чтобы иметь возможность расчитать коэффициент Жаккара для двух строк нам надо преобразовать их в множества. Самый простой вариант, разбить строку на символы. Но обычно берут не символы строки, а k-граммы строки (также известны как n-граммы). <a href="http://en.wikipedia.org/wiki/N-gram">K-грамма</a> – это непрерывная уникальная последовательность из k символов строки. Дублирующие k-граммы пропускают. Например, в слове “клоун” 3 триграммы (k = 3): “кло”, “лоу” и “оун”. На практике, k выбирают равным в диапазоне от двух до четырех, в зависимости от характера данных.</p>

<p>Cформировав из строк множество k-грамм, мы можем расчитать коэффициент Жаккара между этими строками. Например, триграммный коэффициент Жаккара для пары “corolla” и “corola” будет выше, чем для пары “corona” и “corola”. В первом случае совпадают три триграммы: “cor”, “oro” и “rol”, а во втором случае только две: “cor” и “oro”.</p>

<p>В контексте алгоритма автодополнения, для того чтобы иметь возможность быстро подбирать кандидатов на пользователский запрос, необходимо построить <a href="http://nlp.stanford.edu/IR-book/html/htmledition/k-gram-indexes-for-spelling-correction-1.html">k-gram индекс</a> по словарю автодополнения. K-gram индекс это инвертированный индекс из k-граммы в слова содержащие эту k-грамму. K-gram индекс позволяет  быстро находить элементы с наиболее высоким коэффициентом Жаккара предварительно проиндексировав их.</p>

<blockquote>
  <p>Биграммный индекс (k = 2) для слов: “топор”, “компот” и “оптом” выглядит следующим образом:</p>

  <ul>
    <li>то → оптом, топор</li>
    <li>оп → оптом, топор</li>
    <li>по → компот, топор</li>
    <li>ор → топор</li>
    <li>ко → компот</li>
    <li>ом → компот, оптом</li>
    <li>мп → компот</li>
    <li>от → компот</li>
    <li>пт → оптом</li>
  </ul>
</blockquote>

<p>Имея k-gramm индекс алгоритм автодополнения сводится к следующим шагам:</p>

<ol>
  <li>разбить на k-граммы строку введенную пользователем;</li>
  <li>для каждой k-граммы получить список слов в которых она встречается (posting list);</li>
  <li>сделать merge posting list’ов с подсчетом какое количество раз каждое слово встречается в них. По факту это количество совпавших k-грамм между строкой пользователя и позицией словаря.</li>
  <li>отсортировать этот список по убыванию количества совпавших k-грамм;</li>
  <li>вернуть первые N позиций пользователю.</li>
</ol>

<h3 id="section-3">Достоинства</h3>

<ul>
  <li>данная подход позволяет эффективно находить строки синтаксически близкие к целевой (с максимальным количеством пересекающихся k-грамм). Существенно быстрее чем редакционное расстояние.</li>
</ul>

<h3 id="section-4">Недостатки</h3>

<ul>
  <li>как и редакционное расстояние, не позволяет использовать информацию языковой модели, что не позволяет исправлять сложные типы опечаток;</li>
  <li>более сложна в реализации чем подход с редакционным расстоянием.</li>
</ul>

<h2 id="tips--tricks">Tips &amp; tricks</h2>

<p>Некоторые замечания которые могут быть полезны, если вы захотите имплементировать толерантный автокомплит.</p>

<ul>
  <li>K-gram индекс можно хранить в любой удобной для вас inverted index системе. Например, Apache Lucene;</li>
  <li>подходы №1 и №2 не являются взаимоисключающими. Очень часто K-gram индекс из за его эффективности используют как предварительный фильтр для других, более сложных алгоритмов;</li>
  <li>может иметь смысл предварительно убирать из текста все символы не несущие смысловой нагрузки. Например, дефисы, слэши и т.д;</li>
  <li>при построении k-gram из слова/фразы имеет смысл добавить в исходную строку какой-нибудь специальный символ (например, “$”) на границе слов. Это сделает результаты более точным, за счет дополнительной совпадающей k-граммы на границах.</li>
</ul>

<h2 id="e">В заключениe</h2>
<p>Мы рассмотрели два основных инструмента которые позволяют находить и исправлять опечатки. Они могут быть использованы как в чистом виде, так и в составе более сложных стратегий автодополнения. Надеюсь, эта информация даст вам общее представление о том как сделать более толерантное к опечаткам автодополнение.</p>



	<div class="bar">
		<div class="g-plusone" data-size="medium"></div>
		<a href="https://twitter.com/share" class="twitter-share-button"
			data-url="http://bazhenov.me/blog/2012/08/04/autocomplete.html"
			data-via="denis_bazhenov" data-lang="en">Tweet</a>

		<a href="https://twitter.com/denis_bazhenov" class="twitter-follow-button"
			data-show-count="false">Follow</a>
	</div>

	<div id="disqus_thread"></div>
	<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

<!-- Google +1 button -->
<script type="text/javascript">
	(function() {
		var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
		po.src = 'https://apis.google.com/js/plusone.js';
		var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
	})();
</script>

<!-- Twitter buttons -->
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>

<!-- Disqus -->
<script type="text/javascript">
	/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
	var disqus_shortname='severe-reality';
	var disqus_developer=false;

	/* * * DON'T EDIT BELOW THIS LINE * * */
	(function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/javascript">
	MathJax.Hub.Config({
		tex2jax: {
			inlineMath: [['$','$'], ['\\(','\\)']],
			processEscapes: true
		}
	});
</script>

		<footer>
			<div class="content">
				<a href="http://feeds.feedburner.com/severe-reality">RSS Subscribe</a>
					|
				<a href="mailto:dotsid@gmail.com">Email</a>
			</div>
		</footer>
					
	</div>
	
	<script src="http://yandex.st/highlightjs/6.1/highlight.min.js"></script>
	<script>
	$(document).ready(function() {
		$('pre.code code').each(function(i, e) {hljs.highlightBlock(e, '  ')});
	});
	</script>
	
	
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-31484732-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</body>
</html>