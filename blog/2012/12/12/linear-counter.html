<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ru" lang="ru-ru">
<head>
	 <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
	 <meta http-equiv="content-type" content="text/html; charset=utf-8" />
	 <title>Линейный счетчик</title>
	 <meta name="author" content="Denis Bazhenov" />
	 <link href="http://feeds.feedburner.com/severe-reality" rel="alternate" title="Severe Reality" type="application/atom+xml" />
	 <link href='http://fonts.googleapis.com/css?family=Open+Sans:300,400,600&subset=latin,cyrillic-ext,cyrillic' rel='stylesheet' type='text/css'>
	 
	 <link rel="openid2.provider" href="https://www.google.com/accounts/o8/ud?source=profiles" > 
	 <link rel="openid2.local_id" href="http://www.google.com/profiles/dotsid" >
	 
	 <!-- syntax highlighting CSS -->
	 <link rel="stylesheet" href="/css/syntax.css" type="text/css" />
	 <!-- Homepage CSS -->
	 <link rel="stylesheet" href="/css/screen.css" type="text/css" media="screen, projection" />
	 <link rel="stylesheet" href="http://yandex.st/highlightjs/6.1/styles/idea.min.css">

	<script src="http://code.jquery.com/jquery-1.7.1.min.js"></script>
</head>
<body>

	<div class="site">
		
			<header>
				<div class="content">
					<a href="/">Суровая реальность</a>
				</div>
			</header>
		

		<div class="post content">
	<h1>Линейный счетчик</h1>
	<div class="meta">
		<span class="date">12 December 2012</span>
		<span class="tags">
			
				<a href="/tags.html#algorithms">algorithms</a>
			
				<a href="/tags.html#math">math</a>
			
				<a href="/tags.html#probability">probability</a>
			
		</span>
		
	</div>
	
	
	<p>Допустим, вам необходимо рассчитать количество уникальных строк в файле. Причем, файл большой – миллионы или десятки миллионов строк. Типичный shell’овский однострочник который позволяет решить эту задачу выглядит следующим образом:</p>

<pre class="shell"><code>sort | uniq | wc -l
</code></pre>

<p>И все бы хорошо, но есть одна проблема. Имя ей <code>sort</code>.</p>

<!-- excerpt -->

<p>Сортировка <script type="math/tex">O(n \log n)</script> по времени и <script type="math/tex">O(n)</script> по памяти, поэтому время её работы очень быстро перерастает все разумные пределы. Как вариант, можно хранить не сами строки, а их контрольные суммы. Это снизит как требования по памяти, так и асимптотическую оценку по времени до <script type="math/tex">O(n)</script>. Но хранение контрольных сумм подразумевает наличие коллизий, поэтому вы можете получить не точную оценку, а приблизительную. В случаях когда приблизительной оценки достаточно мы можем разменять точность алгоритма на его скорость и требования к памяти.</p>

<p>Существует один очень простой алгоритм который позволяет вычислять оценку количества уникальных объектов в потоке с довольно высокой точностью за линейное время, используя <em>0.1 бита на один уникальный объект</em>. Да да, вы не ослышались в одном бите хранится информация о десяти уникальных объектах.</p>

<h2 id="section">Алгоритм линейного счетчика</h2>

<p>Ладно, я вас обманул. Невозможно в одном бите хранить информацию о десяти объектах. Но можно хранить тот факт что мы уже встречали хотя бы один из объектов привязанных к этому биту. Именно эта идея лежит в основе алгоритма.</p>

<p>Представьте, что у вас есть битовый вектор из 1000 бит, и вы устанавливаете в нем 1000 случайных бит (некоторые биты будут установлены более одного раза). Если вы теперь посчитаете сколько битов установлено в единицу, то получите число близкое к 630. Если вам интересно почему в итоге получается именно такое число, то об этом <a href="/blog/2012/04/16/one-in-a-million.html">я уже писал</a>.</p>

<p>Верно и обратное. Если мы встречаем битовый вектор длины <script type="math/tex">n</script> в котором примерно 63% бит установлено в единицу, это значит что надо этим вектором было произведено примерно <script type="math/tex">n</script> операций установки бита в единицу, при условии что биты выбирались равновероятно.</p>

<p>Таким, довольно нехитрым, способом можно восстановить оценку количества уникальных объектов на основании population count битового вектора (количества бит установленных в единицу). Сделать это можно используя следующую формулу: <script type="math/tex"> l \log(\frac{l}{N_f}) </script>, где <script type="math/tex">l</script> — длина вектора, а <script type="math/tex">N_f</script> количество свободных (нулевых) бит (логарифм обязан быть натуральным).</p>

<p>На графике ниже приведена <a href="https://gist.github.com/4267208">симуляция</a> для вектора длины 10000. В него индексировалось указанное количество объектов, затем получалась доля установленных бит и на её основании восстанавливалась оценка количества добавленных объектов.</p>

<p class="image"><img src="/images/linear-counter/fig1.png" alt="Тестирование линейного счетчика" /></p>

<p>Точность оценки естественным образом связана с отношением количества уникальных объектов к длине битового вектора. Оказывается, что даже если количество добавляемых объектов превышает длину вектора в десять раз, вы по-прежнему можете получать достаточно точные оценки. Погрешность при этом составляет порядка 1%. Это означает, что если в потоке 100 миллионов уникальных объектов, для получения более менее приемлемой оценки достаточно 10 мегабайт памяти.</p>

<h2 id="section-1">Реализация</h2>

<p>Реализация этого алгоритма довольно простая. Самое главное, это хеш-функция с равномерным распределением. Любая криптографическая функция вполне подойдет.</p>

<p>Консольная утилита способная делать быстрый estimate количества уникальных строк в pipe’е иногда очень кстати. Поэтому, я реализовал <a href="https://github.com/bazhenov/linear-counter">линейный счетчик на C++</a>. Вы можете использовать этот код в качестве примера. Если же вы пишете на Java, то есть замечательный проект <a href="https://github.com/clearspring/stream-lib">stream-lib</a> в котором помимо линейного счетчика есть масса других вероятностных алгоритмов которые могут оказаться очень полезными при работе с большими массивами данных.</p>

<h2 id="section-2">Ссылки по теме</h2>

<ul>
  <li>Kyu Y. Whang, Brad T. Vander Zanden, and Howard M. Taylor. <a href="http://dblab.kaist.ac.kr/Publication/pdf/ACM90_TODS_v15n2.pdf">A linear-time probabilistic counting algorithm for database applications.</a> ACM Trans. Database Syst., 15(2):208–229, 1990;</li>
  <li><a href="http://highlyscalable.wordpress.com/2012/05/01/probabilistic-structures-web-analytics-data-mining/">Probabilistic Data Structures for Web Analytics and Data Mining</a> — Ilya Katsov.</li>
</ul>



	<div class="bar">
		<div class="g-plusone" data-size="medium"></div>
		<a href="https://twitter.com/share" class="twitter-share-button"
			data-url="http://bazhenov.me/blog/2012/12/12/linear-counter.html"
			data-via="denis_bazhenov" data-lang="en">Tweet</a>

		<a href="https://twitter.com/denis_bazhenov" class="twitter-follow-button"
			data-show-count="false">Follow</a>
	</div>

	<div id="disqus_thread"></div>
	<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

<!-- Google +1 button -->
<script type="text/javascript">
	(function() {
		var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
		po.src = 'https://apis.google.com/js/plusone.js';
		var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
	})();
</script>

<!-- Twitter buttons -->
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>

<!-- Disqus -->
<script type="text/javascript">
	/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
	var disqus_shortname='severe-reality';
	var disqus_developer=false;

	/* * * DON'T EDIT BELOW THIS LINE * * */
	(function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/javascript">
	MathJax.Hub.Config({
		tex2jax: {
			inlineMath: [['$','$'], ['\\(','\\)']],
			processEscapes: true
		}
	});
</script>

		<footer>
			<div class="content">
				<a href="http://feeds.feedburner.com/severe-reality">RSS Subscribe</a>
					|
				<a href="mailto:dotsid@gmail.com">Email</a>
			</div>
		</footer>
					
	</div>
	
	<script src="http://yandex.st/highlightjs/6.1/highlight.min.js"></script>
	<script>
	$(document).ready(function() {
		$('pre.code code').each(function(i, e) {hljs.highlightBlock(e, '  ')});
	});
	</script>
	
	
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-31484732-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</body>
</html>