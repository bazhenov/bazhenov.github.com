<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ru" lang="ru-ru">
<head>
	 <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
	 <meta http-equiv="content-type" content="text/html; charset=utf-8" />
	 <title>Pipelining</title>
	 <meta name="author" content="Denis Bazhenov" />
	 <link href="http://feeds.feedburner.com/severe-reality" rel="alternate" title="Severe Reality" type="application/atom+xml" />
	 <link href='http://fonts.googleapis.com/css?family=Open+Sans:300,400,600&subset=latin,cyrillic-ext,cyrillic' rel='stylesheet' type='text/css'>
	 
	 <link rel="openid2.provider" href="https://www.google.com/accounts/o8/ud?source=profiles" > 
	 <link rel="openid2.local_id" href="http://bazhenov.me/" >
	 
	 <!-- syntax highlighting CSS -->
	 <link rel="stylesheet" href="/css/syntax.css" type="text/css" />
	 <!-- Homepage CSS -->
	 <link rel="stylesheet" href="/css/screen.css" type="text/css" media="screen, projection" />
	 <link rel="stylesheet" href="http://yandex.st/highlightjs/6.1/styles/idea.min.css">

	<script src="http://code.jquery.com/jquery-1.7.1.min.js"></script>
</head>
<body>

	<div class="site">
		
			<header>
				<div class="content">
					<a href="/">Суровая реальность</a>
				</div>
			</header>
		

		<div class="post content">
	<h1>Pipelining</h1>
	<div class="meta">
		<span class="date">01 August 2009</span>
		<span class="tags">
			
				<a href="/tags.html#concurrency">concurrency</a>
			
		</span>
		
	</div>
	
	
	<p>Существует одна очень старая и эффективная техника — конвейерная обработка данных (pipelining). Ее смысл заключается в том, что разные физические исполнители, которые могут работать не блокируя друг друга (хвала <a href="http://en.wikipedia.org/wiki/Direct_memory_access">DMA</a>), такие как: процессоры, жесткие диски, сетевые карты, — должны работать не блокируя друг друга. Это позволяет повысить их утилизацию, и, если правильно все организовать, не допустить перегрузки отдельно взятых исполнителей. Отличительной особенностью этой техники является то, что она используется в <a href="http://en.wikipedia.org/wiki/Instruction_pipeline">микропроцессорах</a> с незапамятных времен, и сейчас является неотъемлемой частью любого <a href="http://en.wikipedia.org/wiki/Superscalar">суперскалярного процессора</a>.</p>

<p>Представьте себе следующий код:</p>

<pre class="code"><code>while ( !isInterrupted() ) {
  byte[] data = performComplexIOOperation();
  performComplexProcessing(data);
}
</code></pre>

<p>Довольно типичная ситуация. Сначала мы читаем данные, потом обрабатываем. Если каждая из фаз (чтение/обработка) в отдельности требует много времени, то этот код не сможет полностью утилизовать ни процессор ни подсистему ввода/вывода. Что мы можем сделать для того, чтобы более полно утилизовать ресурсы машины, на которой работает приложение?</p>

<p>Давайте посмотрим на то, чем занимается наш поток выполняющий этот код.</p>

<p class="image"><img src="/images/pipelining/fig1.png" alt="Figure 1" /></p>

<p>Вполне очевидно, что ни IO, ни CPU не загружены на 100%. Причиной является то, что один поток работает сразу с двумя физическими исполнителями, не давая возможности этим исполнителям работать параллельно. В тот момент, когда процессор обрабатывает данные, жесткому диску нечем заняться. Пока жесткий диск читает данные, у процессора нет работы. Вы можете сказать: &ldquo;Так ведь процессор не просто ждет. Он ждет данных от жесткого диска&rdquo;. Все верно, но чего ждет жесткий диск пока процессор обрабатывает очередную порцию данных?</p>

<p>Это приводит нас к следующим двум правилам:</p>

<ul>
  <li>поток занимающий процессор не должен иметь причин для блокировки;</li>
  <li>поток не занимающий процессор может иметь только один ресурс, который может служить причиной его блокировки (конечно все иначе, если вы используете какую-либо из моделей неблокирующего ввода/вывода).</li>
</ul>

<p>Другими словами, поток управления должен работать только с одним исполнителем. Можете это считать <a href="http://en.wikipedia.org/wiki/Single_responsibility_principle">принципом единичной ответственности</a> для многопоточного программирования.</p>

<p>Мы можем вынести чтение в отдельный поток и связать потоки при помощи очереди задач.</p>

<pre class="code"><code>class ReadingThread implements Runnable {

  private final Queue&lt;ByteBuffer&gt; queue;
  [...]
  public void run() {
    while ( !isInterrupted() ) {
      queue.add( performComplexIOOperation() );
    }
  }
}

class ProcessingThread implements Runnable {

  private final Queue&lt;ByteBuffer&gt; queue;
  [...]
  public void run() {
    while ( !isInterrupted() ) {
      ByteBuffer buffer = queue.poll();
      performComplexProcessing(buffer);
    }
  }
}
</code></pre>

<p>В этом случае картина будет выглядеть примерно следующим образом.</p>

<p class="image"><img src="/images/pipelining/fig2.png" alt="Figure 2" /></p>

<p>Теперь мы имеем загруженный жесткий и один загруженный процессор. Что мы можем сделать еще?</p>

<p>Если задача обработки хорошо распараллеливается, то мы можем делегировать обработку данных не отдельному потоку, а пулу потоков. Тем самым мы можем утилизовать несколько процессоров.</p>

<p class="image"><img src="/images/pipelining/fig3.png" alt="Figure 3" /></p>

<p>Стоит отметить, что java предоставляет все необходимые синхронизационные примитивы для реализации конвейерной обработки данных, такие как: <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/ConcurrentLinkedQueue.html">конкурентные очереди</a> и <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/Executor.html">пулы потоков</a>.</p>

<p>Закрепление за отдельным исполнителем отдельного потока дает ряд преимуществ:</p>

<ul>
  <li>не имея других причин для блокировки кроме как на этом исполнителе, мы способны утилизовать его полностью. По-крайней мере, до тех пор пока коммуникационный механизм (например, очередь при помощи которой передаются данные между потоками) не станет bottleneck&rsquo;ом;</li>
  <li>так как не существует большого количества потоков работающего с исполнителем мы не допускаем его перегрузки.</li>
</ul>

<p>Второй аспект очень важен. Вы должны понимать, что большое количество потоков вредит системе. В случае процессора это высокий context switch&rsquo;инг, что пагубно влияет на производительность. В случае жесткого диска мы можем забыть про sequential read.</p>

<p>Стоит отметить, что <em>коммуникация между потоками не может быть бесплатной</em>. Не смотря на то, что существуют довольно эффективные алгоритмы для реализации <a href="http://www.ibm.com/developerworks/java/library/j-jtp04186/index.html">неблокирующих очередей</a>, делегировать сложение двух чисел в отдельный поток все же не стоит. Коммуникационные расходы будут дороже, чем выполнение задачи.</p>



	<div class="bar">
		<div class="g-plusone" data-size="medium"></div>
		<a href="https://twitter.com/share" class="twitter-share-button"
			data-url="http://bazhenov.me/blog/2009/08/01/pipelining.html"
			data-via="denis_bazhenov" data-lang="en">Tweet</a>

		<a href="https://twitter.com/denis_bazhenov" class="twitter-follow-button"
			data-show-count="false">Follow</a>
	</div>

	<div id="disqus_thread"></div>
	<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

<!-- Google +1 button -->
<script type="text/javascript">
	(function() {
		var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
		po.src = 'https://apis.google.com/js/plusone.js';
		var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
	})();
</script>

<!-- Twitter buttons -->
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>

<!-- Disqus -->
<script type="text/javascript">
	/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
	var disqus_shortname='severe-reality';
	var disqus_developer=false;

	/* * * DON'T EDIT BELOW THIS LINE * * */
	(function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>

		<footer>
			<div class="content">
				<a href="http://feeds.feedburner.com/severe-reality">RSS Subscribe</a>
					|
				<a href="mailto:dotsid@gmail.com">Email</a>
			</div>
		</footer>
					
	</div>

	<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
	
	<script src="http://yandex.st/highlightjs/6.1/highlight.min.js"></script>
	<script>
	$(document).ready(function() {
		$('pre.code code').each(function(i, e) {hljs.highlightBlock(e, '  ')});
	});
	</script>
	<script type="text/javascript">
		MathJax.Hub.Config({
			tex2jax: {
				inlineMath: [['$','$'], ['\\(','\\)']],
				processEscapes: true
			}
		});
	</script>
	
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-31484732-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</body>
</html>