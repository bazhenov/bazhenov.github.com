<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ru" lang="ru-ru">
<head>
	 <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
	 <meta http-equiv="content-type" content="text/html; charset=utf-8" />
	 <title>Программисты и железо</title>
	 <meta name="author" content="Denis Bazhenov" />
	 <link href="http://feeds.feedburner.com/severe-reality" rel="alternate" title="Severe Reality" type="application/atom+xml" />

	 <link href='http://fonts.googleapis.com/css?family=Open+Sans:300,400,600&subset=latin,cyrillic-ext,cyrillic' rel='stylesheet' type='text/css'>
	 <!-- syntax highlighting CSS -->
	 <link rel="stylesheet" href="/css/syntax.css" type="text/css" />

	 <!-- Homepage CSS -->
	 <link rel="stylesheet" href="/css/screen.css" type="text/css" media="screen, projection" />
	 <link rel="stylesheet" href="http://yandex.st/highlightjs/6.1/styles/idea.min.css">

	<script src="http://code.jquery.com/jquery-1.7.1.min.js"></script>
</head>
<body>

	<div class="site">

		<header>
			<div class="content">
				<a href="/">Суровая реальность</a>
			</div>
		</header>

		<div class="post content">
	<h1>Программисты и железо</h1>
	<div class="meta">
		<span class="date">20 March 2010</span>
		<span class="tags">
			
				<a href="/tags.html#hardware">hardware</a>
			
				<a href="/tags.html#theory">theory</a>
			
		</span>
		
	</div>
	
	
	<p>Не так давно у нас на работе (Виктор, Игорь, Олег привет вам) состоялась дискуссия на тему: должны ли программисты знать как работает железо на котором выполняются их программы? И я еще раз убедился в том, что большинство программистов придерживаются мнения: &ldquo;железо само по себе, а я сам по себе&rdquo;. Точка зрения вполне ожидаемая и ничего принципиально неправильного в ней нет, но я хотел бы &ldquo;копнуть глубже&rdquo;.</p>

<p>Вообще, мне кажется вопрос &ldquo;стоит ли программистам изучать железо&rdquo; в чем-то похож на вопрос &ldquo;стоит ли программистам изучать математику&rdquo;, — ответ неоднозначен. Существует множество вопросов, ответы на которые могут повлиять на окончательное решение: в какой предметной области вы работаете, насколько эти конкретные знания ценны для вас и т.д. Это вопрос <a href="http://ru.wikipedia.org/wiki/Окупаемость_инвестиций">инвестиций и прибыли</a>. В данном случае под инвестициями подразумевается в первую очередь ваше свободное время, а под прибылью — профессиональные навыки и знания, которые позволят вам более эффективно делать вашу работу. Тогда вопрос сводится к следующему: <em>чем изучение железа может помочь нам программистам делать свою работу лучше</em>?</p>

<p>Мы с вами живем в эпоху высокоуровневых языков. Программисты большинства отраслей с успехом забыли про unmanaged языки, не говоря уже об ассемблерных вставках. В этом есть свои преимущества. Во-первых, это позволило нам программистам быть более эффективными. При равных доступных ресурсах теперь мы можем решать более сложные задачи. Во-вторых, не требуя от программистов &ldquo;погружения в железо&rdquo;, мы позволяем им специализироваться в своей области, а также увеличить их количество за счет более короткой learning curve. Последнее впрочем имеет и свои негативные последствия, но я не буду сейчас акцентировать на них внимание.</p>

<p>И все же знание железа может быть полезно. Но позвольте мне сразу оговорится, я <em>не</em> считаю что результатом погружения в hardware должен стать код более быстрый с точки зрения машины. Да, иногда это является самоцелью и приходится экономить буквально говоря миллисекунды, но в текущем контексте я хочу акцентировать внимание на другом аспекте.</p>

<h2 id="section">Почему стоит изучать?</h2>

<p>Как бы программистам не хотелось думать, что они никоим образом не зависят от аппаратной платформы, — это не так. Да, компиляторы, виртуальные машины и операционные системы перевели среднестатистического программиста на &ldquo;дальнюю орбиту&rdquo; в аппаратных вопросах. Но железо все же влияет на то, какими абстракциями мы пользуемся для написания программ. Просто мы не всегда это замечаем.</p>

<p>Возьмите хотя бы возросший интерес, к <a href="http://en.wikipedia.org/wiki/Actor_model">actor&rsquo;ам</a>. В общем и целом actor&rsquo;ы представляют собой модель кооперативной многозадачности. Если вы хорошо помните историю, то кооперативная многозадачность в широких масштабах последний раз &ldquo;<a href="http://ru.wikipedia.org/wiki/Windows_3.x">упоминалась</a>&rdquo; в начале 90-х. У нее есть один существующий минус — она не работает на маленьком количестве исполнителей. Когда у вас один процессор легко может случится так, что какая-либо задача оккупирует его и другие задачи не смогут выполнятся. Тем не менее, у кооперативной многозадачности есть плюсы которые заставили нас опять обратить свой взор на эту модель&hellip;</p>

<p>Дело в том, что основная проблема с которой сталкиваются современные модели распараллеливания (которые преимущественно основаны на потоках) — это context switch. Доступ к памяти не является random&rsquo;ным, чтобы ни говорили разработчики железа. Latency доступа к памяти на современных платформах составляет <em>сотни тактов</em> процессора. За это время процессор может сделать много работы. Эту проблему сейчас адресуют довольно простым путем — кеш, размер которого уже достигает 2Mb и больше на ядро. Проблемы кеша вам уже <a href="/blog/2009/08/01/cache.html">должны быть известны</a>, — они одни и те же, неважно говорим ли мы о CPU cache или о memcached. Как только вы получаете промах кеша, вы платите performance penalty. Именно cache miss&rsquo;ы являются источником деградации производительности в случае высокого context switching&rsquo;а<sup id="fnref:cache-miss"><a href="#fn:cache-miss" rel="footnote">1</a></sup>. Об этом говорило очень много умных дядек<sup id="fnref:goetz"><a href="#fn:goetz" rel="footnote">2</a></sup> <sup id="fnref:cliff"><a href="#fn:cliff" rel="footnote">3</a></sup> <sup id="fnref:evolution"><a href="#fn:evolution" rel="footnote">4</a></sup>.</p>

<p>Решение довольно очевидно. Не переключатся между задачами лишний раз, только после завершения всей задачи целиком. Здравствуй кооперативная многозадачность. Не верите мне, <a href="http://users.livejournal.com/_foreseer/43339.html">поверьте сотрудникам Яндекса</a>. Не зря в Windows существуют <a href="http://en.wikipedia.org/wiki/Fiber_(computer_science)">fiber&rsquo;ы</a>.</p>

<p>Справедливости ради, следует заметить, что скорость не единственный (и лично для меня не главный) плюс модели actor&rsquo;ов. Эта модель гораздо проще в понимании и тестировании чем традиционные thread-based приложения. Но интерес к этой модели начал появляться как раз в тот момент, когда традиционные способы увеличения производительности исчерпали себя и мы начали искать новые методы обеспечения роста. А это означает одну простую вещь — <em>программные абстракции используемые нами меняются в том числе и под &ldquo;давлением аппаратных факторов&rdquo;</em>.</p>

<p>У каждого технического решения есть свои причины влияющие на его формирование. Не всегда эти причины лежат непосредственно в области программной инженерии. <em>Знание аппаратных факторов дает программисту более полную картину того, почему мир в котором мы живем таков каков он есть</em>. Это основная идея, которую на мой взгляд не обосновано игнорирует большинство программистов.</p>

<p>Никто не просит вас уметь программировать на ассемблере и разбираться в opcode&rsquo;ах микропроцессора. Но осознание того как работает процессор и какие bottleneck&rsquo;и есть у существующих аппаратных платформ может дать вам очень хороший теоретический background для решения многих задач и ответа на многие вопросы.</p>

<h2 id="root-of-all-evil">Root of all evil</h2>

<p class="image"><img src="http://windowsclient.net/blogs/damonwildercarr/WindowsLiveWriter/GetMoreLinqOperationsandIntegratet.5only_B9AA/premature_6_2.jpg" alt="Root of all evil" /></p>

<p>Иногда можно встретить мнение что изучение железа плохо уже потому что человек изучающий железо приобретает некоторую зашоренность мышления и начинает оценивать решения лишь с точки зрения их аппаратной производительности.</p>

<p>Верная предпосылка, но абсолютно не рациональный вывод. Это не проблема знаний, это проблема человека использующего эти знания. Чувство меры и здравоумие ни в коей мере не должно вас покидать, какие бы знания вы не получали.</p>

<h2 id="tradeoffs">Tradeoffs</h2>

<p>С другой стороны надо трезво оценивать свои возможности. Существует масса знаний/умений которые для программиста важнее чем знание железа. Вот, на мой взгляд, всего лишь некоторые из них (перечислено в произвольном порядке):</p>

<ul>
  <li>ОО анализ и проектирование (шаблоны/SOLID принципы);</li>
  <li>анализ и построение алгоритмов;</li>
  <li>классические структуры данных;</li>
  <li>диагностика типичных проблемных ситуаций;</li>
  <li>тестирование и поддержка legacy систем;</li>
  <li>умение писать корректный многопоточный код, а также находить ошибки в многопоточном коде (светлое будущее с Clojure, Erlang, Scala, whatever еще не наступило);</li>
  <li>функциональная декомпозиция;</li>
  <li>автоматизация процесса разработки;</li>
  <li>продолжите список&hellip;</li>
</ul>

<p>Если вы чувствуете, что есть важные знания из области программной инженерии которые для вас на данный момент важнее чем знание железа, то выбор очевиден. В первую очередь мы должны развиваться в тех направлениях которые диктует нам наша сфера деятельности.</p>

<h2 id="section-1">В итоге</h2>

<p>Саморазвитие, как это ни странно, требует жертв. Иногда приходится тратить время на изучение вещей, изучать которые совсем не хочется. Лично для меня таким инструментом в свое время был <code>git</code>. Но, видимо, иногда для того чтобы стать лучше приходится &ldquo;наступать своей песне на горло&rdquo;. Так что я верю, что рано или поздно, если вы хотите стать хорошим программистом, <em>вам придется выйти из своего дома и посмотреть как живут ваши соседи</em>.</p>

<div class="footnotes">
  <ol>
    <li id="fn:cache-miss">
      <p><a href="http://www.cs.rochester.edu/u/cli/research/switch.pdf">Quantifying The Cost of Context Switch</a><a href="#fnref:cache-miss" rel="reference">&#8617;</a></p>
    </li>
    <li id="fn:goetz">
      <p><a href="http://www.infoq.com/presentations/brian-goetz-concurrent-parallel">Brian Goetz: From Concurrent to Parallel</a><a href="#fnref:goetz" rel="reference">&#8617;</a></p>
    </li>
    <li id="fn:cliff">
      <p><a href="http://www.infoq.com/presentations/click-crash-course-modern-hardware">Cliff Click: A Crash Course in Modern Hardware</a><a href="#fnref:cliff" rel="reference">&#8617;</a></p>
    </li>
    <li id="fn:evolution">
      <p><a href="http://www.youtube.com/watch?v=BBMeplaz0HA">Norm Jouppi: Future Evolution of High-Performance Microprocessors</a><a href="#fnref:evolution" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>


	<div class="bar">
		<div class="g-plusone" data-size="medium"></div>
		<a href="https://twitter.com/share" class="twitter-share-button"
			data-url="http://bazhenov.me/blog/2010/03/20/hardware.html"
			data-via="denis_bazhenov" data-lang="en">Tweet</a>

		<a href="https://twitter.com/denis_bazhenov" class="twitter-follow-button"
			data-show-count="false">Follow</a>
	</div>

	<div id="disqus_thread"></div>
	<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

<!-- Google +1 button -->
<script type="text/javascript">
	(function() {
		var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
		po.src = 'https://apis.google.com/js/plusone.js';
		var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
	})();
</script>

<!-- Twitter buttons -->
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>

<!-- Disqus -->
<script type="text/javascript">
	/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
	var disqus_shortname='severe-reality';
	var disqus_developer=true;

	/* * * DON'T EDIT BELOW THIS LINE * * */
	(function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>

		<footer>
			<div class="content">
				<a href="http://feeds.feedburner.com/severe-reality">RSS Subscribe</a>
					|
				<a href="mailto:dotsid@gmail.com">Email</a>
			</div>
		</footer>
					
	</div>

	<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
	
	<script src="http://yandex.st/highlightjs/6.1/highlight.min.js"></script>
	<script>
	$(document).ready(function() {
		$('pre.code code').each(function(i, e) {hljs.highlightBlock(e, '  ')});
	});
	</script>
	<script type="text/javascript">
		MathJax.Hub.Config({
			tex2jax: {
				inlineMath: [['$','$'], ['\\(','\\)']],
				processEscapes: true
			}
		});
	</script>

</body>
</html>