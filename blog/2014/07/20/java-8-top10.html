<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ru" lang="ru-ru">
<head>
	 <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
	 <meta http-equiv="content-type" content="text/html; charset=utf-8" />
	 <title>Top 10 фич Java 8 о которых не говорят</title>
	 <meta name="author" content="Denis Bazhenov" />
	 <link href="http://feeds.feedburner.com/severe-reality" rel="alternate" title="Severe Reality" type="application/atom+xml" />
	 <link href='http://fonts.googleapis.com/css?family=Open+Sans:300,400,600&subset=latin,cyrillic-ext,cyrillic' rel='stylesheet' type='text/css'>
	 
	 <link rel="openid2.provider" href="https://www.google.com/accounts/o8/ud?source=profiles" > 
	 <link rel="openid2.local_id" href="http://www.google.com/profiles/dotsid" >
	 
	 <!-- syntax highlighting CSS -->
	 <link rel="stylesheet" href="/css/syntax.css" type="text/css" />
	 <!-- Homepage CSS -->
	 <link rel="stylesheet" href="/css/screen.css" type="text/css" media="screen, projection" />
	 <link rel="stylesheet" href="http://yandex.st/highlightjs/6.1/styles/idea.min.css">

	<script src="http://code.jquery.com/jquery-1.7.1.min.js"></script>
</head>
<body>

	<div class="site">
		
			<header>
				<div class="content">
					<a href="/">Суровая реальность</a>
				</div>
			</header>
		

		<div class="post content">
	<h1>Top 10 фич Java 8 о которых не говорят</h1>
	<div class="meta">
		<span class="date">20 July 2014</span>
		<span class="tags">
			
				<a href="/tags.html#java">java</a>
			
		</span>
		
	</div>
	
	
	<p>О новых фичах Java 8 <a href="https://leanpub.com/whatsnewinjava8/read">было</a> <a href="http://www.takipiblog.com/2014/03/18/5-features-in-java-8-that-will-change-how-you-code/">сказано</a> <a href="http://www.techempower.com/blog/2013/03/26/everything-about-java-8/">уже</a> <a href="http://www.javaworld.com/article/2078836/java-se/love-and-hate-for-java-8.html">довольно</a> <a href="http://ttux.net/post/java-8-new-features-release-performance-code/">много</a>. В основном обсуждают замыкания, Stream&rsquo;ы, новое API для работы со временем, default-методы в интерфейсах, класс Optional и отсутствие Permanent Generation.</p>

<p>Но помимо жирных фич, в Java 8 сильно изменилась стандартная библиотека по перифирии. В частности, в уже существующие классы было добавлено много методов существенно упрощающих ежедневные задачи. Об этом мы сегодня и поговорим.</p>

<!--excerpt-->

<p>Итак, Top 10 самых не обсуждаемых фич Java 8. Поехали.</p>

<h2 id="stringjoin">String.join()</h2>

<p>Неужто свершилось?! 2014 год на дворе, а в стандартной библиотеке Java появился метод объединяющий набор строк в одну с заданным разделителем.</p>

<pre class="code"><code>String.join(", ", "A", "B", "C"); // A, B, C
</code></pre>

<p>Но лучше поздно чем никогда. Раньше приходилось или плясать со <code>StringBuilder</code>&lsquo;ом, ну или, самый разумный вариант, использовать Guava или commons-lang.</p>

<p>Ещё один вариант использовать <code>Stream&lt;String&gt;</code> и <code>Collectors.joining()</code>:</p>

<pre class="code"><code>Collection&lt;String&gt; strings = ...;
strings.stream()
  .filter(i -&gt; i != null || i.isEmpty())
  .collect(Collectors.joining(", "));
</code></pre>

<p>В этом случае, появляется возможность предварительно отфильтровать пустые строки.</p>

<h2 id="mapcomputeifabsentgetordefaultmergeputifabsent">Map.computeIfAbsent()/getOrDefault()/merge()/putIfAbsent()</h2>

<p>Даю голову на отсечение, если вы пишете на Java, то у вас в проекте есть код похожий на этот:</p>

<pre class="code"><code>Map&lt;String, Integer&gt; data = ...;
for (String s : strings) {
  if (!data.containsKey(key))
    data.put(key, 0);
  data.put(key, data.get(key) + 1);
}
</code></pre>

<p>Суть проста. Есть отображение из строки в счетчик, сколько раз мы встретили эту строку. Надо только не забывать инициализировать позиции <code>Map</code>&lsquo;а нулем, а то виртуальная машина в вас <code>NullPointerException</code> кинет.</p>

<p>В Java 8 эта же задача решается проще:</p>

<pre class="code"><code>for (String s : strings)
  data.merge(s, 1, (a, b) -&gt; a + b);
</code></pre>

<p>Meтод <code>merge</code> принимает ключ, значение и функцию которая объединяет заданное значение и уже существующее в отображении, если таковое имеется. Если в отображении под заданным ключем значения нет, то ложит туда указанное значение.</p>

<p>Для любителей однострочников, есть вариант похардкорней:</p>

<pre class="code"><code>strings.forEach(s -&gt; data.merge(s, 1, (a, b) -&gt; a + b));
</code></pre>

<p>Аналогичную функциональность, но в другом контексте, дают методы:</p>

<ul>
  <li><code>computeIfAbsent()</code> – возвращает или значение из отображения по ключу, или создает его, если его не было;</li>
  <li><code>putIfAbsent()</code> – добавляет значение в отображение, только если его там не было. Этот метод ранее имелся только у <code>ConcurrentMap</code>, теперь появился и у <code>Map</code>&lsquo;а;</li>
  <li><code>getOrDefault()</code> – название довольно красноречиво. Возвращает значение из отображения или переданное значение по-умолчанию. На мой взгляд, <em>метод довольно не идиоматичен</em>. Для работы с отсутствующими значениями был добавлен тип <code>Optional</code>, его и следовало использовать. Поэтому, я бы добавил метод: <code>Optional&lt;V&gt; getOptional(K key)</code>. Но кто я такой&hellip;</li>
</ul>

<h2 id="threadlocalwithinitial">ThreadLocal.withInitial()</h2>

<p>Тех, кто плотно работает с многопоточностью, ничем не пронять. Они как ветераны Вьетнама, и даже флешбеки по ночам так же мучают. И этой конструкцией их не напугаешь:</p>

<pre class="code"><code>// Java 7 и ранее
ThreadLocal&lt;ObjectMapper&gt; mapper = new ThreadLocal&lt;&gt;() {
  @Override
  protected ObjectMapper initialValue() {
    return new ObjectMapper();
  }
};
</code></pre>

<p>Но теперь, за счёт замыканий, стало проще:</p>

<pre class="code"><code>// Java 8
ThreadLocal&lt;ObjectMapper&gt; mapper = withInitial(() -&gt; new ObjectMapper());
</code></pre>

<h2 id="fileslinesreadalllinesbufferedreaderlines">Files.lines()/readAllLines()/BufferedReader.lines()</h2>

<p>В Java 8 стало возможным гораздо проще выполнить такую простую задачу как прочитать построчно файл. Это ещё одна задача, которая раньше требовала довольно много кода. Теперь так:</p>

<p class="incut">Минутка зануды. Метод возвращающий арифметическое среднее в классах <code>*SummaryStatistics</code> называется <code>getAverage()</code>, хотя более точным было бы имя <code>getMean()</code>. Термин mean описывает именно арифметическое среднее, в то время как термин average относится к понятию среднего значения в целом и может относится к любой <a href="http://ru.wikipedia.org/wiki/Меры_центральной_тенденции">мере центральной тенденции</a> (арифметическое среднее, медиана, геометрическое среднее, мода и т.д.). Примечательно, что даже в документации к методу <code>getAverage()</code> фигурирует именно понятие mean: &ldquo;Returns the arithmetic mean of values recorded&rdquo;.</p>

<pre class="code"><code>// на входе файл в формате "одна строка - одно число"
// раcсчитываем среднее всех чисел
int mean = lines(new File("file").toPath())
  .mapToInt(Integer::parseInt)
  .summaryStatistics()
  .getAverage();
</code></pre>

<p>Аналогичный метод был добавлен в класс <code>BufferedReader</code>, поэтому теперь Stream&rsquo;ы доступны поверх любого <code>InputStream</code>&lsquo;а.</p>

<h2 id="comparator">Парадокс Comparator&rsquo;а</h2>

<p>Допустим вам надо написать имплементацию <code>Comparator</code>&lsquo;а для сортировки объектов по-возрастанию. Обычно, компаратор выглядит следующим образом:</p>

<pre class="code"><code>public class ByScoreComparator implements Comparator&lt;User&gt; {

  @Override
  public int compare(User u1, User u2) {
    return (int) signum(o2.getAge() - o1.getAge());
  }
}
</code></pre>

<p>Вопрос лишь в том, что от чего надо отнимать, чтобы получить верный порядок сортировки? Наука говорит, что если вы будете выбирать вариант случайно, то угадаете примерно в половине случаев. В конце концов, варианта всего два: или от <code>u2</code> отнять <code>u1</code> или наоборот.</p>

<p>Парадокс заключается в том, что написать компаратор правильно с первого раза не получается практически никогда. Заканчивается всё всегда одинаково, — флегматичным замечанием: &ldquo;Ах да, я же тут отнял неверно!&rdquo;.</p>

<p>Благо, теперь это и не требуется. Компаратор можно собрать из говна и палок, а точнее из ссылок на методы, которые возвращают <code>Comparable</code> типы или примитивы по которым мы хотим сортировать.</p>

<pre class="code"><code>Comparator&lt;User&gt; comparator = Comparator
  .comparingDouble(User::getAge)
  .thenComparing(User::getName);
List&lt;User&gt; hList = ...;
hList.sort(comparator);
</code></pre>

<h2 id="primitiveiterator">PrimitiveIterator</h2>

<p>Одно из ограничений Java предыдущих версий заключалось в том, что в них не было стандартных итераторов над примитивными типами. Только над ссылочными. Теперь таковые появились в виде интерфейса <code>PrimitiveIterator</code>, а также его наследников: <code>PrimitiveIterator.Of[Int|Long|Double]</code>. Вместе с функциональными интерфейсами над примитивными типами это дает хорошую основу для работы с коллекциями примитивных типов без autobox&rsquo;а.</p>

<h2 id="listreplaceall">List.replaceAll()</h2>

<p>Довольно удобный метод, который позволяет модифицировать все элементы списка. Если вы хотите список строк привести к нижнему регистру, раньше надо было писать что-то вроде:</p>

<pre class="code"><code>List&lt;String&gt; list = ...;
for (int i = 0; i &lt; list.size(); i++)
  list.set(i, list.get(i).toLowerCase());
</code></pre>

<p>Или более продвинутый вариант:</p>

<pre class="code"><code>ListIterator&lt;String&gt; i = list.listIterator();
while (i.hasNext())
  li.set(i.next().toLowerCase());
</code></pre>

<p>Сейчас же можно сделать следующим образом:</p>

<pre class="code"><code>list.replaceAll(String::toLowerCase);
</code></pre>

<h2 id="randomints">Random.ints()</h2>

<p>Ещё одна возможность, о которой практически нет упоминаний, — это то что <code>Random</code> может создавать <code>Stream</code>&lsquo;ы случайных чисел нужного типа и диапазона:</p>

<pre class="code"><code>// Выведет 10 случайных числел от 20 до 100
new Random().ints(10, 20, 100).forEach(System.out::println);
</code></pre>

<p>Есть методы для создания <code>double</code>&lsquo;ов (<code>doubles()</code>) и <code>long</code>&lsquo;ов (<code>longs()</code>).</p>

<h2 id="longaccumulatorlongadder">LongAccumulator/LongAdder</h2>

<p>Два класса, которые представляют собой более производительные замены для <code>AtomicLong</code>. Класс <code>LongAdder</code> позволяет выполнять атомарные арифметические операции над типом <code>long</code>. <code>LongAccumulator</code> принимает произвольную функцию аккумуляции результатов. Эта функция принимает текущее значение, аргумент переданный в метод <code>accumulate()</code> и возвращает результат логического объединения (accumulate) двух значений.</p>

<pre class="code"><code>// ранвосильно new LongAdder()
LongAccumulator a = new LongAccumulator((a, b) -&gt; a + b, 0);
a.accumulate(1);
a.accumulate(2);
a.accumulate(3);
a.accumulate(4);

a.longValue(); // 10
</code></pre>

<p class="incut">При получении результата все элементы редуцируются в один общий результат. Вся эта кухня намекает нам, что функция аккумуляции должна быть коммутативна и ассоциативна. В противном случае результат будет зависеть от физического порядка выполнения операций, который данный класс не гарантирует.</p>

<p>При высоком contention&rsquo;е два данных класса будут быстрее <code>AtomicLong</code>&lsquo;а за счёт того, что операции выполняются не над общим элементом, а над группой элементов по отдельности. Благодаря чему, &ldquo;гусары не подерутся из-за женщин&rdquo;.</p>

<p>Аналогичная пара классов есть для типа <code>Double</code> (<code>DoubleAdder</code>, <code>DoubleAccumulator</code>).</p>

<h2 id="java-flight-recorder">Java Flight Recorder</h2>

<p>Последнее по порядку, но не по важности, — это новые инструменты диагностики, которые предоставила Oracle в Java 8. А именно, Java Flight Recorder. Технически JFR появился в версии 7u40, но это настолько важный инструмент, что не упомянуть о нем я не могу.</p>

<p>Flight Recorder представляет собой инструментарий встроенный в JVM для сбора и диагностики самой виртуальной машины, а также приложений запущенных на ней. Запускается он командой <code>jmc</code>. У JFR есть несколько интересных особенностей:</p>

<ul>
  <li>в зависимости от профиля собираемой информации, издержки на работу JFR могут быть очень низкими (менее 1% по утверждению Oracle, при конфигурации по-умолчанию). Это позволяет использовать этот инструмент в &ldquo;боевых условиях&rdquo; и под нагрузкой;</li>
  <li>JFR, в отличии от инструментов вроде VisualVM, может вести постоянную запись диагностической информации в ring buffer, и имеет настраиваемые политики dump&rsquo;а информации на диск. Это позволяет настроить виртуальную машину таким образом, чтобы она постоянно вела диагностический лог, а сохраняла его только в случае возникновения проблем (например, при систематической нехватке CPU). Такой подход позволяет получать &ldquo;черные ящики&rdquo; описывающие состояние виртуальной машины и приложения непосредственно в момент проявления проблемы. До JFR единственный способ локализовать проблему был, — поймать её на production&rsquo;е что называется &ldquo;за руку&rdquo;.</li>
</ul>

<p>Какую информацию может собирать JFR? Её очень много, основные моменты, которые я считаю полезными:</p>

<ul>
  <li>результаты семплинга кода (какие классы и методы заняли больше всего процессорного времени, в каких потоках);</li>
  <li>информация по всем GC циклам (сколько памяти было высвобождено, сколько времени заняла каждая сборка мусора);</li>
  <li>информация по аллокации памяти (из какого потока, класса и метода было выделено больше всего памяти, под какой тип данных выделяли больше всего памяти, скорость выделения по времени);</li>
  <li>информация по сетевому и дисковому вводу/выводу;</li>
  <li>какие Exception&rsquo;ы и Error&rsquo;ы были сгенерированы приложением;</li>
  <li>профиль блокировки потоков (какие потоки чаще всего блокируются, на каких локах/мониторах, какие потоки на момент блокировки владеют этими локами/мониторами чаще всего).</li>
</ul>

<p class="image"><img src="/images/java-8-top10/TLAB-1.png" alt="Профиль выделения памяти по потокам" /></p>

<p class="image"><img src="/images/java-8-top10/TLAB-2.png" alt="Профиль выделения памяти" /></p>

<p class="image"><img src="/images/java-8-top10/hot-threads.png" alt="Потоки потребляющие больше всего CPU" /></p>

<p>Список можно было бы продолжить, но в рамках этого поста я не смогу достаточно полно описать JFR. Поэтому, всем заинтересованым лицам настоятельно рекомендую <a href="https://www.youtube.com/playlist?list=PLKCk3OyNwIzsEVDq6zErLW7HSkY7aqdeT">потратить время на изучение</a> этого крайне полезного инструмента.</p>

<h2 id="section">Заключение</h2>

<p>Реальный список гораздо больше. Если вам интересно что ещё добавили в Java 8, я настоятельно рекомендую поискать по стандартной библиотеке Java следующим regexp&rsquo;ом: <code>@since\s+1.8\s*\n</code>. Вы найдете более 1000 вхождений. Ни один блог пост этого не покроет.</p>

<p>Оставляйте в комментариях, какие из фич Java 8 вы используете чаще всего.</p>


	<div class="bar">
		<div class="g-plusone" data-size="medium"></div>
		<a href="https://twitter.com/share" class="twitter-share-button"
			data-url="http://bazhenov.me/blog/2014/07/20/java-8-top10.html"
			data-via="denis_bazhenov" data-lang="en">Tweet</a>

		<a href="https://twitter.com/denis_bazhenov" class="twitter-follow-button"
			data-show-count="false">Follow</a>
	</div>

	<div id="disqus_thread"></div>
	<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

<!-- Google +1 button -->
<script type="text/javascript">
	(function() {
		var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
		po.src = 'https://apis.google.com/js/plusone.js';
		var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
	})();
</script>

<!-- Twitter buttons -->
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>

<!-- Disqus -->
<script type="text/javascript">
	/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
	var disqus_shortname='severe-reality';
	var disqus_developer=false;

	/* * * DON'T EDIT BELOW THIS LINE * * */
	(function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/javascript">
	MathJax.Hub.Config({
		tex2jax: {
			inlineMath: [['$','$'], ['\\(','\\)']],
			processEscapes: true
		}
	});
</script>

		<footer>
			<div class="content">
				<a href="http://feeds.feedburner.com/severe-reality">RSS Subscribe</a>
					|
				<a href="mailto:dotsid@gmail.com">Email</a>
			</div>
		</footer>
					
	</div>
	
	<script src="http://yandex.st/highlightjs/6.1/highlight.min.js"></script>
	<script>
	$(document).ready(function() {
		$('pre.code code').each(function(i, e) {hljs.highlightBlock(e, '  ')});
	});
	</script>
	
	
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-31484732-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</body>
</html>