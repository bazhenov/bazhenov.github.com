<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Суровая реальность</title>
    <link>http://bazhenov.me</link>
    <atom:link href="http://bazhenov.me/rss.xml" rel="self" type="application/rss+xml" />
    <description>Суровая реальность</description>
    <language>ru-ru</language>
    <pubDate>Tue, 05 Jun 2012 23:43:41 +1100</pubDate>
    <lastBuildDate>Tue, 05 Jun 2012 23:43:41 +1100</lastBuildDate>
    
    <item>
      <title>О задачах классификации</title>
      <link>http://bazhenov.me/blog/2012/06/05/classification.html</link>
      <pubDate>Tue, 05 Jun 2012 00:00:00 +1100</pubDate>
      <author>dotsid@gmail.com (Denis Bazhenov)</author>
      <guid>http://bazhenov.me/blog/2012/06/05/classification</guid>
      <description>&lt;p&gt;В этом и следующих постах, я хочу на пальцах описать процесс создания простого классификатора текстовых документов, а также рассказать о некоторых нетипичных с обывательской точки зрения подходах используемых при классификации документов.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://ru.wikipedia.org/wiki/Классификация_документов&quot;&gt;Классификатор&lt;/a&gt; – это алгоритм соотносящий некие входные данные с одним или несколькими классами. В отличии от алгоритмов &lt;a href=&quot;http://ru.wikipedia.org/wiki/Кластерный_анализ&quot;&gt;кластеризации&lt;/a&gt; эти классы должны быть определены заранее. &lt;/p&gt;

&lt;p&gt;Возможно, кому-то это определение покажется слишком общими или академическим, поэтому лучше наверное рассмотреть задачу классификации на примерах. А примеров хоть отбавляй.&lt;/p&gt;

&lt;!-- excerpt --&gt;

&lt;h2 id=&quot;section&quot;&gt;Они повсюду&lt;/h2&gt;

&lt;p&gt;Пожалуй самый яркий пример автоматической классификации – это фильтрация спама. Каждый день на мой ящик падает десятки если не сотни спам-писем, которые автоматически отфильтровываются из моего inbox&amp;rsquo;а.&lt;/p&gt;

&lt;p class=&quot;image photo&quot;&gt;&lt;img src=&quot;http://bazhenov.me/images/classification/spam.png&quot; alt=&quot;Mail Spam&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Современные коммерческие системы способны успешно фильтровать спам с точностью превышающей 99%&lt;sup id=&quot;fnref:google-spam-filter-performance&quot;&gt;&lt;a href=&quot;#fn:google-spam-filter-performance&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;. Другим довольно типичным примером классификации служит автоматическое определение тематики того или иного текста. Некоторые новостные аггрераторы используют подобный подход для группировки новостей в направления: экономика, политика, общественная жизнь и т.д.&lt;/p&gt;

&lt;p&gt;Зачастую классификация является фундаментом на котором строятся алгоритмы решения более сложных задач.
Например, классификация используется при создании рекомендательных систем и в частности при реализации &lt;a href=&quot;http://ru.wikipedia.org/wiki/Коллаборативная_фильтрация&quot;&gt;коллаборативной фильтрации&lt;/a&gt;.&lt;/p&gt;

&lt;p class=&quot;image photo&quot;&gt;&lt;img src=&quot;http://bazhenov.me/images/classification/recommendation.png&quot; alt=&quot;Amazon recommendations&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Safari Reader Mode является еще одним примером где используются алгоритмы классификации для достижения конечной цели. Суть этого режима работы браузера заключается в том что он позволяет автоматически убрать со страницы всю шелуху не имеющую отношения к сути контента страницы&lt;sup id=&quot;fnref:boilerplate-paper&quot;&gt;&lt;a href=&quot;#fn:boilerplate-paper&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p class=&quot;image photo&quot;&gt;&lt;img src=&quot;http://bazhenov.me/images/classification/reader-mode.png&quot; alt=&quot;Safari Reader Mode&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Так же классификация используется в задачах face detection&amp;rsquo;а и face recognition&amp;rsquo;а.&lt;/p&gt;

&lt;p class=&quot;image photo&quot;&gt;&lt;img src=&quot;http://bazhenov.me/images/classification/face-detection.png&quot; alt=&quot;Face Detection in Aperture&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Классификация используется как инструмент для решения множества других задач:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;снятие омонимии при обработке натуральных языков;&lt;/li&gt;
  &lt;li&gt;в поисковых системах – для ограничения области поиска в целях повышения точности (вертикальный поиск);&lt;/li&gt;
  &lt;li&gt;автоматическое определение языка на котором написан текст;&lt;/li&gt;
  &lt;li&gt;анализ тональности (определение эмоциональной окраски текста).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Этот список можно продолжать еще долго. Например, в медицине алгоритмы классификации используются для реконструирования 3D модели головного мозга по серии МРТ снимков&lt;sup id=&quot;fnref:mri-3d&quot;&gt;&lt;a href=&quot;#fn:mri-3d&quot; rel=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;, а также для диагностики пациентов страдающих синдромом Альцгеймера&lt;sup id=&quot;fnref:alzheimer&quot;&gt;&lt;a href=&quot;#fn:alzheimer&quot; rel=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;Традиционные подходы&lt;/h2&gt;

&lt;h3 id=&quot;rule-based-classification&quot;&gt;Rule based classification&lt;/h3&gt;

&lt;p&gt;Если говорить о задаче классификации текстов, то пожалуй ее традиционным решением является классификация основная на правилах (rule based classification). Вы имплементируете правила определения класса документа по его тексту в виде &lt;code&gt;if-then-else&lt;/code&gt; выражений (код на Scala).&lt;/p&gt;

&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;def classify(text: String) =
	if (text.contains(&quot;виагра&quot;) || text.contains(&quot;бухгалтер&quot;)) &quot;SPAM&quot; else &quot;NOT SPAM&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Этот подход может быть хорошим вариантом если вы работаете с небольшой коллекцией документов которую вы способны охватить и тщательно проанализировать. Просто потому что вы четко контролируете правила по которым классификатор принимает решения. Но есть у этого подхода и очевидные минусы:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;для того чтобы выбрать значимые для классификации слова необходимо обладать экспертными знаниями в предметной области. Есть ли у вас например соображения по поводу ключевых слов которые хорошо отличают документы посвященные финансовой тематике от документов экономической? У меня очень смутные;&lt;/li&gt;
  &lt;li&gt;отнюдь не всегда факт наличия или отсутствия какого-либо одного слова является решающим фактором для принятия решения.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Поподробней остановлюсь на последнем пункте. Если вернуться к задаче определения спама и немного подумать о том какие слова являются хорошими классификационными признаками (classifying feature), то станет понятно что нет такого слова наличие которого гарантировало бы что сообщение является спамом. Возможно, в пределах компании производящей &lt;a href=&quot;http://ru.wikipedia.org/wiki/Силденафил&quot;&gt;силденафил&lt;/a&gt; в промышленных масштабах слово &amp;ldquo;виагра&amp;rdquo; не является показательным признаком спам-сообщения, кто знает.&lt;/p&gt;

&lt;p&gt;В общем, суть такова: &lt;em&gt;любое из известных спам-слов пусть редко но встречается в повседневной жизни.&lt;/em&gt; Поэтому, принимать окончательно решение основываясь на факте наличия или отсутствия какого-либо одного слова идея контрпродуктивная. Мы можем усложнять правила добавляя вложенные &lt;code&gt;if&lt;/code&gt;&amp;lsquo;ы. Но довольно быстро вы поймете что возможности человека в формулировании таких правил очень ограничены, потому что &lt;em&gt;сложность правил растет экспоненциально с количеством выбранных для классификации слов&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&quot;weight-based-classification&quot;&gt;Weight based classification&lt;/h3&gt;

&lt;p&gt;Мы можем пойти другим путем. Мы можем для каждого слова выбрать некий вес, который будет означать насколько вероятно что сообщение с этим словом является спамом (0 – никогда не является спамом, 1 – всегда спам).&lt;/p&gt;

&lt;table class=&quot;center&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&amp;nbsp;&lt;/th&gt;
      &lt;th&gt;spam&lt;/th&gt;
      &lt;th&gt;not spam&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;бухгалтер&lt;/td&gt;
      &lt;td&gt;0.99&lt;/td&gt;
      &lt;td&gt;0.01&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;виагра&lt;/td&gt;
      &lt;td&gt;0.99&lt;/td&gt;
      &lt;td&gt;0.01&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;выгодное&lt;/td&gt;
      &lt;td&gt;0.70&lt;/td&gt;
      &lt;td&gt;0.30&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;github&lt;/td&gt;
      &lt;td&gt;0.01&lt;/td&gt;
      &lt;td&gt;0.99&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;В этой таблице перечислены гипотетические веса для четырех слов. Сумма значений в строке должна быть равна единице. Тогда наша классификация может выглядеть следующим образом:&lt;/p&gt;

&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;def classify(text: String) = {
	val weights = Map(&quot;бухгалтер&quot;-&amp;gt;0.9, &quot;виагра&quot;-&amp;gt;0.99, &quot;выгодное&quot;-&amp;gt;0.7, &quot;github&quot;-&amp;gt;0.01)
	val words = text.split(' ').filter(weights.contains(_))
	val P_spam = words.map(weights(_)).reduce(_ * _)
	val P_not_spam = words.map(1 - weights(_)).reduce(_ * _)
	if (P_spam &amp;gt; P_not_spam) &quot;SPAM&quot; else &quot;NOT SPAM&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Мы берем каждое слово и определяем суммарный вес документа отдельно для класса &amp;ldquo;спам&amp;rdquo; и класса &amp;ldquo;не спам&amp;rdquo;. Суммарный вес определяется как произведение весов всех известных слов документа. Слова для которых у нас нет веса мы пропускаем при классификации. Какой суммарный вес оказался больше тот класс и побеждает.&lt;/p&gt;

&lt;p&gt;Это более разумный подход, так как он более гибок и принимает решение на основании всех известных слов в тексте. Так же его гораздо проще сопровождать чем полотна &lt;code&gt;if&lt;/code&gt;&amp;lsquo;ов. &lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;Метод машинного обучения&lt;/h2&gt;

&lt;p&gt;А теперь очень важное замечание. &lt;em&gt;Если у нас будет некий способ автоматически подобрать оптимальные веса слов, то данный подход можно считать методом &lt;a href=&quot;http://ru.wikipedia.org/wiki/Машинное_обучение&quot;&gt;машинного обучения&lt;/a&gt;&lt;/em&gt;. Сильно упрощенный, возможно даже гипертрофированный, но по своей сути это именно метод машинного обучения.&lt;/p&gt;

&lt;p&gt;Если быть более точным, то описанный мною метод является зародышем &lt;a href=&quot;http://ru.wikipedia.org/wiki/Наивный_байесовский_классификатор&quot;&gt;наивного байесовского классификатора&lt;/a&gt;. Но не позволяйте названию обмануть вас, NBC (Naïve Bayes Classifier) если не самый, то один из самых часто используемых классификаторов. Тому есть ряд причин:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;он прост в имплементации и тестировании;&lt;/li&gt;
  &lt;li&gt;процесс обучения довольно эффективен по сравнению с другими более сложными классификаторами;&lt;/li&gt;
  &lt;li&gt;на небольших корпусах документов разница между NBC и другими гораздо более сложными алгоритмами классификации зачастую несущественна, а иногда NBC может оказаться и более точным&lt;sup id=&quot;fnref:on-bayes-optimality&quot;&gt;&lt;a href=&quot;#fn:on-bayes-optimality&quot; rel=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;В последующих заметках я более детально опишу вопросы связанные с созданием и тестированием подобного классификатора. Подписывайтесь на &lt;a href=&quot;http://bazhenov.me/rss.xml&quot;&gt;RSS&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;Ссылки по теме&lt;/h2&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:google-spam-filter-performance&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://googlesystem.blogspot.com/2007/10/how-gmail-blocks-spam.html&quot;&gt;How Gmail Blocks Spam&lt;/a&gt;&lt;a href=&quot;#fnref:google-spam-filter-performance&quot; rel=&quot;reference&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:boilerplate-paper&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://www.l3s.de/~kohlschuetter/publications/wsdm187-kohlschuetter.pdf&quot;&gt;Boilerplate Detection using Shallow Text Features&lt;/a&gt;&lt;a href=&quot;#fnref:boilerplate-paper&quot; rel=&quot;reference&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:mri-3d&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://ieeexplore.ieee.org/xpl/login.jsp?tp=&amp;amp;arnumber=1352574&amp;amp;url=http%3A%2F%2Fieeexplore.ieee.org%2Fiel5%2F9356%2F29717%2F01352574.pdf%3Farnumber%3D1352574&quot;&gt;Automatic classification of MRI images for three-dimensional volume reconstruction by using general regression neural networks&lt;/a&gt;&lt;a href=&quot;#fnref:mri-3d&quot; rel=&quot;reference&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:alzheimer&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://www.ncbi.nlm.nih.gov/pubmed/20542124&quot;&gt;Automatic classification of patients with Alzheimer&amp;rsquo;s disease from structural MRI: a comparison of ten methods using the ADNI database&lt;/a&gt;&lt;a href=&quot;#fnref:alzheimer&quot; rel=&quot;reference&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:on-bayes-optimality&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://www.cc.gatech.edu/fac/Charles.Isbell/classes/reading/papers/bayes-opt.pdf&quot;&gt;On the Optimality of the Simple Bayesian Classifier under Zero-One Loss&lt;/a&gt;&lt;a href=&quot;#fnref:on-bayes-optimality&quot; rel=&quot;reference&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Особенности функциональщины в Java</title>
      <link>http://bazhenov.me/blog/2012/05/12/functional-java.html</link>
      <pubDate>Sat, 12 May 2012 00:00:00 +1100</pubDate>
      <author>dotsid@gmail.com (Denis Bazhenov)</author>
      <guid>http://bazhenov.me/blog/2012/05/12/functional-java</guid>
      <description>&lt;p&gt;Некоторое время назад мне довелось участвовать в одном из подпроектов целью которого было извлечение упоминаний об автомобилях из произвольного текста с использованием экспертной информации. Это задачу в простонародье называют парсингом :). Так или иначе, этот класс задач имеет свою специфику связанную с относительно большим количеством различных операций над коллекциями. Связано это с необходимостью проверки различных гипотез относительно содержимого анализируемого текста. Оперирование над коллекциями это сильная сторона функциональных языков к которым Java конечно же не относится.&lt;/p&gt;

&lt;!-- excerpt --&gt;

&lt;h2 id=&quot;section&quot;&gt;Императивный подход&lt;/h2&gt;

&lt;p&gt;Классический императивный подход к оперированию коллекциями заключается в написании кода выполняющего обход и обработку каждого элемента коллекции. Типичный map в императивном стиле выглядит следующим образом:&lt;/p&gt;

&lt;pre class=&quot;code java&quot;&gt;&lt;code&gt;List&amp;lt;String&amp;gt; result = new ArrayList&amp;lt;String&amp;gt;();
for (Position p : autocomplete.suggest(q)) {
	result.add(p.getTitle());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Не так уж и плохо. Но когда подобную операцию надо выполнять несколько раз в пределах одного метода, &lt;code&gt;for&lt;/code&gt;&amp;lsquo;ы начинают мозолить глаз.&lt;/p&gt;

&lt;h2 id=&quot;guava---&quot;&gt;Guava спешит на помощь&lt;/h2&gt;

&lt;p&gt;Мы используем &lt;a href=&quot;http://code.google.com/p/guava-libraries/&quot;&gt;guava&lt;/a&gt; (бывшая google collections) для упрощения оперирования коллекциями. Guava предоставляет массу функциональных примитивов для работы с коллекциями. Несмотря на излишний синтаксический шум, в Java можно применять элементы функционального программирования. Правда не без ограничений. Давайте посмотрим на вышеприведенный пример переписанный с использованием guava.&lt;/p&gt;

&lt;pre class=&quot;code java&quot;&gt;&lt;code&gt;List&amp;lt;String&amp;gt; result = transform(autocomplete.suggest(q), new Function&amp;lt;Position, String&amp;gt;() {
  @Override
  public String apply(final Position input) {
    return input.getTitle();
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Если честно, то стало еще хуже. Если раньше у нас был простой и понятный &lt;code&gt;for&lt;/code&gt;-цикл, то сейчас мешанина из ключевых слов и названий типов. На сегодняшний день это пожалуй самое сильное ограничение Java — &lt;em&gt;объявлять предикаты по месту проблематично из-за синтаксиса анонимных классов&lt;/em&gt;. Поэтому мы пошли на следующее ухищрение.&lt;/p&gt;

&lt;h2 id=&quot;map-&quot;&gt;Вынос предикатов и map-функций&lt;/h2&gt;

&lt;p&gt;Если вы писали в функциональном стиле, то может замечали что существенный процент всех функций передаваемых в &lt;code&gt;filter&lt;/code&gt;/&lt;code&gt;map&lt;/code&gt; являются чистыми функциями (без состояния) и не используют замыкание. Поэтому мы решили вынести их в виде статических членов класса к которым они относятся. Это позволяет определить их один раз в рамках класса к которому они привязаны и использовать в любом месте кодовой базы.&lt;/p&gt;

&lt;p&gt;Например, вышеприведенный пример мы переписываем следующим образом:&lt;/p&gt;

&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;class Position {

	public static final Function&amp;lt;Position, String&amp;gt; retrieveName = new Function&amp;lt;Position, String&amp;gt;() {
		@Override
		public String apply(final Position input) {
			return input.getTitle();
		}
	};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Тогда клиент сводится к следующему коду:&lt;/p&gt;

&lt;pre class=&quot;code java&quot;&gt;&lt;code&gt;List&amp;lt;String&amp;gt; result = transform(autocomplete.suggest(q), retrieveName);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;что уже довольно вменяемо. В случае если функция обладает состоянием мы делаем для нее статическую фабрику в классе к которому она относится.&lt;/p&gt;

&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;class Span {
	
	public static Function&amp;lt;Span, String&amp;gt; chopFromText(final String text) {
		checkNotNull(text);
		return new Function&amp;lt;Span, String&amp;gt;() {
			@Override
			public String apply(Span input) {
				return input.cutFrom(text);
			}
		};
	}
	
	public String cutFrom(String string) {
		return string.substring(start, end);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;при этом клиент выглядит похожим образом:&lt;/p&gt;

&lt;pre class=&quot;code java&quot;&gt;&lt;code&gt;List&amp;lt;Span&amp;gt; spans = asList(new Span(0, 5), new Span(6, 2), new Span(9, 3));
List&amp;lt;String&amp;gt; words = transform(spans, chopFromText(&quot;Hello to you!&quot;));
// words -&amp;gt; [&quot;Hello&quot;, &quot;to&quot;, &quot;you&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Этот подход работает благодаря тому что предикаты и map-функции принимают ровно один аргумент по типу которого можно определить к какому классу относить эту функцию. Таким образом, всякий раз когда вам нужен предикат на тип &lt;code&gt;Position&lt;/code&gt; вы знаете что его надо искать именно в классе &lt;code&gt;Position&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;Постскриптум&lt;/h2&gt;

&lt;p&gt;Вы никогда не получите от Java экспрессивности присущей функциональным и тем более динамическим языкам. Поэтому в некотором отношении это конечно полумера. Но сделать свою жизнь немного проще используя элементы функционального программирования все же можно. И я считаю нужно.&lt;/p&gt;

&lt;p&gt;Ну а Java программистам которые незнакомы с guava, я настоятельно советую обратить внимание на эту библиотеку. Она содержит массу вспомогательных классов и статических методов для решения типовых задач возникающий в ежедневной практике. Ее описание с легкостью может занять целый пост, настолько обширен ее функционал.&lt;/p&gt;

</description>
    </item>
    
    <item>
      <title>Гармоническое среднее</title>
      <link>http://bazhenov.me/blog/2012/05/05/harmonic-mean.html</link>
      <pubDate>Sat, 05 May 2012 00:00:00 +1100</pubDate>
      <author>dotsid@gmail.com (Denis Bazhenov)</author>
      <guid>http://bazhenov.me/blog/2012/05/05/harmonic-mean</guid>
      <description>&lt;p&gt;Сегодня я хочу обсудить следующую проблему. Как мониторить CPU usage на многопроцессорной машине? Конечно же мониторить метрики выдываемые &lt;code&gt;mpstat&lt;/code&gt;. Эта программа выдает процент времени который процессор проводит в различных состояниях (&lt;code&gt;user&lt;/code&gt;, &lt;code&gt;system&lt;/code&gt;, &lt;code&gt;iowait&lt;/code&gt;, &lt;code&gt;idle&lt;/code&gt; и т.д.).&lt;/p&gt;

&lt;!--excerpt--&gt;

&lt;pre class=&quot;shell&quot;&gt;&lt;code&gt;$ mpstat 1
Linux 2.6.32-200.13.1.el5uek (search-personal2.vfarm.loc)		05/05/2012 	_x86_64_	(16 CPU)

11:35:52 AM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest   %idle
11:35:53 AM  all    8.34    0.00    0.59    0.06    0.00    0.12    0.00    0.00   90.89
11:35:54 AM  all    7.27    0.00    0.86    0.00    0.00    0.36    0.00    0.00   91.51
11:35:55 AM  all    7.80    0.00    0.45    0.06    0.00    0.17    0.00    0.00   91.53
11:35:56 AM  all    5.33    2.17    0.84    0.00    0.00    0.14    0.00    0.00   91.52
11:35:57 AM  all    5.92    0.00    0.40    0.06    0.00    0.06    0.00    0.00   93.57
11:35:58 AM  all    4.71    0.07    0.42    0.00    0.00    0.14    0.00    0.00   94.67
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В ретроспективе это выглядит следующим образом:&lt;/p&gt;

&lt;p class=&quot;image photo&quot;&gt;&lt;img src=&quot;http://bazhenov.me/images/harmonic-mean/fig1.png&quot; alt=&quot;CPU usage&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Может показаться что у этого сервера нет никаких проблем с CPU. Тем не менее надо учитывать что машина многопроцессорная и может оказаться что нагрузка на ядра не симмитрична. &lt;code&gt;mpstat&lt;/code&gt; же показывает арифметическое среднее, поэтому если вы на 16 процессорной машине видите CPU utilization 6% это может означать:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;машина загружена симметрично и у каждого ядра есть еще масса свободного времени;&lt;/li&gt;
  &lt;li&gt;машина загружена не симметрично – одно ядро работает на 100%, а все остальные курят бамбук.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Конечно же последний случай это явная проблема и система мониторинга должна позволять находить такие ситуации. Но что мониторить чтобы находить ассиметричную нагрузку на различные ядра?&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;Мониторинг&lt;/h2&gt;

&lt;h3 id=&quot;load-average&quot;&gt;Load average&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Load_(computing)&quot;&gt;Load average&lt;/a&gt; (&lt;code&gt;uptime&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt;) не позволяет отследить подобную ассиметричность в нагрузке, так как ее следствием является работа, которая не может быть выполнена параллельно. В этом случае в системе не будет длинной очереди CPU scheduler&amp;rsquo;а, а это именно то что и показывает load average.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;Мониторить отдельно каждое ядро&lt;/h3&gt;
&lt;p&gt;Можно отслеживать ассиметричность имея информацию по CPU usage для каждого отдельного ядра (на подобии той которая приведена в начале заметки). Но это, как вы можете догадаться довольно напряжно. Слишком много данных, которые надо пропустить через мозг чтобы получить информацию.&lt;/p&gt;

&lt;h3 id=&quot;cpu-utilization&quot;&gt;Экстремальные значения CPU utilization&lt;/h3&gt;
&lt;p&gt;Можно мониторить например максимальное значение CPU utilization. Это позволит понять какая утилизация у самого загруженного ядра в системе. Благодаря этому можно отследить ситуацию ассиметричной нагрузки по разнице между арифметическим средним и максимальным значением утилизации.&lt;/p&gt;

&lt;p&gt;Мы мониторим &lt;a href=&quot;http://en.wikipedia.org/wiki/Harmonic_mean&quot;&gt;гармоническое среднее&lt;/a&gt;. &lt;em&gt;Гармоническое среднее, в отличии арифметического стремится к нулю когда хотя бы одно из значений стремится к нулю.&lt;/em&gt; Считается оно тоже довольно просто — количество значений деленное на сумму обратных значений:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{n}{\sum\limits_{i=1}^n \frac{1}{x_i}}&lt;/script&gt;

&lt;p&gt;То есть для двух процессоров idle которых равен 3 и 100, гармоническое среднее равно: &lt;script type=&quot;math/tex&quot;&gt;\frac{2}{\frac{1}{3} + \frac{1}{100}} \approx 5.8&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Если добавить на график который я привел выше, гармоническое среднее утилизации, то мы получим следующее:&lt;/p&gt;

&lt;p class=&quot;image photo&quot;&gt;&lt;img src=&quot;http://bazhenov.me/images/harmonic-mean/fig2.png&quot; alt=&quot;CPU Harmonic Utilization&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Здесь видно что большую часть времени нагрузка распределяется равномерно (светло синей области практически не видно). Тем не менее в период с 1:10 до 1:20 нагрузка на CPU ассиметрична, что говорит о выполнении задачи которая не может быть распараллелена.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;Что может быть причиной?&lt;/h2&gt;

&lt;p&gt;Это может быть любая активность которая не может быть эффективно распараллелена. Например, банальный &lt;code&gt;grep&lt;/code&gt; по большому объему данных (если он не упрется в I/O), сжатие, потоковое кодирование видео, шифрование, некоторые алгоритмы GC в JVM однопоточные по своей природе.&lt;/p&gt;

&lt;p&gt;Более подробно об этом явлении я уже писал ранее в заметке &amp;ldquo;&lt;a href=&quot;http://bazhenov.me/blog/2009/01/13/moores-law-a-la-finita.html&quot;&gt;Конец эры закона Мура&lt;/a&gt;&amp;rdquo;.&lt;/p&gt;

&lt;p class=&quot;update&quot;&gt;В коментариях мне подсказали что стоит также посмотреть в &lt;code&gt;/proc/interrupts&lt;/code&gt; и в графы &lt;code&gt;%irq&lt;/code&gt; и &lt;code&gt;%soft&lt;/code&gt; вывода &lt;code&gt;mpstat&lt;/code&gt;. На системах с высокой сетевой или дисковой нагрузкой может быть довольно большое число прерываний на одном ядре.&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;Что делать в этой ситуации?&lt;/h2&gt;
&lt;p&gt;Во-первых, надо понять является ли это проблемой. Вполне возможно, что эта ситуация может быть вызвана какой-нибудь background задачей, которая ни коим образом не затрагивает пользователей. Если же данная ситуация влияет на качество сервиса предоставляемого пользователям, то определенно надо более точно локализовать проблему и попытаться разрешить ее.&lt;/p&gt;

&lt;p&gt;На ОС Linux в диагностике подобного рода проблем вам могут помочь следующие инструменты:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;команда &lt;code&gt;pidstat -u -t -p $PID 1&lt;/code&gt; позволяет выяснить какие потоки указанного процесса кушают CPU наиболее активно. Эта команда может быть использована в том числе и для диагностики проблем JVM приложений, так как потоки JVM напрямую соотносятся с потоками ОС;&lt;/li&gt;
  &lt;li&gt;для получения информации по потокам JVM может быть полезна команда &lt;code&gt;jstack $PID&lt;/code&gt;, которая делает thread dump JVM приложения (&lt;code&gt;jstack&lt;/code&gt; является частью JDK и не входит в комплект поставки JRE);&lt;/li&gt;
  &lt;li&gt;для получения трейса конкретного потока можно воспользоваться командами &lt;code&gt;strace&lt;/code&gt;/&lt;code&gt;ltrace&lt;/code&gt;. Они показывают трейс системных вызовов и библиотечных вызовов соответственно.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Надеюсь эти инструменты помогут вам диагностировать подобные ситуации быстро и безболезненно.&lt;/p&gt;

</description>
    </item>
    
    <item>
      <title>Один на миллион</title>
      <link>http://bazhenov.me/blog/2012/04/16/one-in-a-million.html</link>
      <pubDate>Mon, 16 Apr 2012 00:00:00 +1100</pubDate>
      <author>dotsid@gmail.com (Denis Bazhenov)</author>
      <guid>http://bazhenov.me/blog/2012/04/16/one-in-a-million</guid>
      <description>&lt;p&gt;Вам наверное приходилось слышать что-то вроде: &amp;ldquo;Этого не может быть. Вероятность этого менее одной миллионной&amp;rdquo;. В бытовом понимании одна миллионная это некая несвершимая вероятность. Другими словами, этого просто не может произойти. Но насколько это вeрятное событие, если вы повторите эксперимент миллион раз? Конечно, вероятность наблюдать событие растет если вы повторяете эксперимент много раз подряд. Но все равно мы зачастую подсознательно пытаемся игнорировать такие события считая их невероятными.&lt;/p&gt;

&lt;!-- excerpt --&gt;

&lt;p&gt;Тем не менее, в современных Интернет-системах которые обрабатывают миллионы запросов в сутки не заметить в течение дня событие с вероятностью в одну миллионную довольно сложно. И вот почему. Вероятность что интересующее нас событие (с исходной вероятностью &lt;code&gt;1/n&lt;/code&gt;) не проявит себя ни в одном из &lt;code&gt;n&lt;/code&gt; независимых экспериментов равно:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(1-\frac{1}{n})^n&lt;/script&gt;

&lt;p&gt;В этой формуле $\frac{1}{n}$ — вероятность события которое реализуется в одном эксперименте из &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;. &lt;script type=&quot;math/tex&quot;&gt;1-\frac{1}{n}&lt;/script&gt; соответственно вероятность что это событие не реализуется в ходе эксперимента. Ну и не тяжело догодаться что $(1-\frac{1}{n})^n$ это вероятность с которой это событие не реализуется в ходе &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; независимых экспериментов. Для n = 1 000, если вы его подставите в формулу, итоговое значение вероятности составит 0.368 или 36.8%. Для n = 1 000 000, значение вероятности составит&amp;hellip; те же самые 36.8%! &lt;em&gt;Редкость события всегда уравновешивается частотой повторения испытаний.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Обоснование этого возможно контринтуитивного результата кроется во &lt;a href=&quot;http://ru.wikipedia.org/wiki/Замечательные_пределы#.D0.92.D1.82.D0.BE.D1.80.D0.BE.D0.B9_.D0.B7.D0.B0.D0.BC.D0.B5.D1.87.D0.B0.D1.82.D0.B5.D0.BB.D1.8C.D0.BD.D1.8B.D0.B9_.D0.BF.D1.80.D0.B5.D0.B4.D0.B5.D0.BB&quot;&gt;втором замечательном пределе&lt;/a&gt;, который большинству из нас преподавали в ходе курса высшей математики.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\lim_{n \to +\infty}(1+\frac{1}{n})^n = e&lt;/script&gt;

&lt;p&gt;Второй замечательный предел интенсивно используется при решении дифференциальных уравнений, но нас интересует одно из следствий этого предела.&lt;/p&gt;

&lt;p&gt;Этот предел говорит нам о том что при растущем &lt;code&gt;n&lt;/code&gt;, значение выражения &lt;script type=&quot;math/tex&quot;&gt;(1-\frac{1}{n})^n&lt;/script&gt; стремится к значению &lt;script type=&quot;math/tex&quot;&gt;\frac{1}{e}&lt;/script&gt;, которое является той самой константой приблизительно равной 0.368.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Я не буду здесь приводить доказательство этого следствия второго замечательного предела. Предел разумного количества формул на один пост достигнут :).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Теперь давайте соберем все это вместе. Предположим что у вас есть некий баг (скажем, race condition в многопоточном приложении), который воспроизводится с вероятностью один на миллион. Фактически что говорит этот предел – если вы обслужите за день миллион запросов то вероятность того что этот баг не порявит себя ни в одном из запросов ~37%. То есть с вероятностью ~63% этот баг даст о себе знать &lt;em&gt;хотя бы один раз&lt;/em&gt; за сутки.&lt;/p&gt;

&lt;p&gt;Из этого можно сделать еще один вывод. Чем больше запросов вы обрабатываете за сутки, тем более редкие явления вы будете наблюдать в течение суток. 100 000 запросов в сутки? Тогда вероятность &lt;script type=&quot;math/tex&quot;&gt;\frac{1}{1 000 00}&lt;/script&gt; для вас не редкость. 10 000 000? Тогда и одной десятимиллионной вас не удивишь.&lt;/p&gt;

&lt;p&gt;Да пребудет с вами нормальное распределение!&lt;/p&gt;

</description>
    </item>
    
    <item>
      <title>О высокой нагрузке</title>
      <link>http://bazhenov.me/blog/2012/02/26/highload.html</link>
      <pubDate>Sun, 26 Feb 2012 00:00:00 +1100</pubDate>
      <author>dotsid@gmail.com (Denis Bazhenov)</author>
      <guid>http://bazhenov.me/blog/2012/02/26/highload</guid>
      <description>&lt;p&gt;В последнее время все чаще говорят о &lt;em&gt;высоконагруженных&lt;/em&gt; приложениях. Нельзя не заметить что это теперь очень популярная, можно даже сказать модная, область знаний. Сам же термин &amp;ldquo;высоконагруженная система&amp;rdquo; при этом не имеет в нашей отрасли четкого определения. В этой заметке я хочу привести свои рассуждения по этому вопросу. Я не ставлю перед собой цель дать исчерпывающее определение этого термина. Моя цель, предоставить читателю ключевую информацию о системах такого рода, которая определяет стиль мышления при работе с ними.&lt;/p&gt;

&lt;!-- excerpt --&gt;

&lt;p&gt;Итак, что такое высоконагруженная система? Ответ на этот вопрос стоит начать с описания качественных свойств такого рода систем.&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;Традиционные качества высоконагруженной системы&lt;/h2&gt;
&lt;p&gt;Как правило, к таким качествам относят большое количество пользователей и данных. В целом это правда, но тут есть несколько загвоздок:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;это не вся правда;&lt;/li&gt;
  &lt;li&gt;приведенные факторы являются количественными, а не качественными.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ниже на основании предпосылки &amp;ldquo;много пользователей, много данных&amp;rdquo; я сформирую список качественных факторов присущих высоконагруженным системам. Начнем с самого простого.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;Многопользовательская система&lt;/h3&gt;
&lt;p&gt;Конечно же высоконагруженное приложение в первую очередь является многопользовательским. То есть в один момент времени с ним работает более чем один человек. Сейчас, в эру стремительного развития Интернета, это тысячи и сотни тысяч человек.&lt;/p&gt;

&lt;p&gt;Устойчивая ассоциация высоконагруженных систем с большим количеством пользователей в нашей индустрии появилась давным давно. Ничего принципиально неверного в такой связи нет. Но если высокая нагрузка подразумевает большое количество пользователей, то большое количество пользователей совсем не обязательно подразумевает высоконагруженную систему.&lt;/p&gt;

&lt;p&gt;Если посмотреть на статистику Московского метрополитена за 2010 год, то окажется что средняя часовая нагрузка на систему максимальна в диапазоне от 8 до 9 часов утра&lt;sup id=&quot;fnref:ref-metro-stat&quot;&gt;&lt;a href=&quot;#fn:ref-metro-stat&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;. За этот час через турникеты проходят приблизительно 720 тысяч человек. Что порождает необходимость не менее 200 раз в секунду проверять статус предъявленных проездных и принимать решение о пропуске того или иного человека через турникет. В Интернете существует масса высоконагруженных ресурсов с подобными показателями пропускной способности. Например, статистика по StackOverflow за тот же 2010-й год показывает что их средняя пропускная способность находится в диапазоне 100-150 хитов в секунду&lt;sup id=&quot;fnref:ref-stackoverflow-stat&quot;&gt;&lt;a href=&quot;#fn:ref-stackoverflow-stat&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;Определенно у метрополитена более высокие требования к пропускной способности. Но значит ли это что Московский метрополитен можно считать более &amp;ldquo;высоконагруженным&amp;rdquo; чем StackOverflow? Вряд ли, в частности потому что эти две системы оперируют несравнимыми объемами информации, о чем мы поговорим позже.&lt;/p&gt;

&lt;p&gt;Я намерено в обоих случаях привел оценку пропускной способности, так как она дает больше информации о нагрузке чем количество пользователей системы. Две разные системы могут подталкивать пользователей к разным паттернам их использования. Это может приводить к абсолютно разным требованиям по пропускной способности для этих систем. Пропускная способность точнее описывает количество работы которую должна уметь выполнять система в единицу времени.&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;Распределенная система&lt;/h3&gt;
&lt;p&gt;Высоконагруженные системы являются системами распределенными, то есть работают более чем на одном сервере. Зачастую это десятки и сотни серверов. Требование распределенности вытекает из следующих причин:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;необходимости обрабатывать возрастающие объемы данных;&lt;/li&gt;
  &lt;li&gt;необходимости &amp;ldquo;живучести&amp;rdquo; системы в случаях отказа части серверов.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Но обо всем по порядку…&lt;/p&gt;

&lt;p&gt;Я наверное не ошибусь если скажу что большинство высоконагруженных приложений являются Интернет-приложениями (позже мы еще вернемся к состоятельности этой гипотезы). А отличительной особенностью современного Интернета основанного на концепции &lt;a href=&quot;http://ru.wikipedia.org/wiki/Веб_2.0&quot;&gt;Web 2.0&lt;/a&gt; является тот факт, что сами пользователи генерируют данные, которые они сами же в итоге и потребляют. Это приводит к тому, что чем больше у вас пользователей, тем больше потенциальный объем хранимых данных.&lt;/p&gt;

&lt;p&gt;Требование обработки больших объемов данных может существенно осложнить жизнь. Под &amp;ldquo;большим объемом&amp;rdquo; я подразумеваю такой объем информации, который не может эффективно обработать одна машина. В большинстве случаев, это объем превышающий объем доступной на сервере оперативной памяти. То есть приходится тем или иным образом распределять данные между несколькими машинами, каждая из которых обрабатывает свой небольшой кусочек данных, но делает это эффективно, без page fault&amp;rsquo;ов (не используя swap) и прочих неприятностей. Необходимость эффективной обработки данных диктуется другим очень важным качеством высоконагруженных систем, – интерактивностью, о котором будет сказано ниже.&lt;/p&gt;

&lt;p&gt;Но большие объемы данных – это не все. Ко всему к этому хочется чтобы система работала в режиме 24x7 без остановок и перерывов. Но вот незадача, любое даже самое надежное оборудование иногда выходит из строя. Встает естественная задача обеспечения доступности системы в случаях отказа оборудования. &lt;/p&gt;

&lt;p&gt;Тут мы вступаем в область знания распределенных систем, эксплуатация которых редко бывает безоблачной, даже когда вы используете готовые решения. Тем не менее распределенные системы, не смотря на сложность их разработки и поддержки, пожалуй единственный подход позволяющий обеспечить вышеизложенные требования в полной мере.&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;Позитивная динамика по пользователям и данным&lt;/h3&gt;
&lt;p&gt;Если ваше приложение представляет хоть какой-то интерес, то даже если ничего не делать, ваша аудитория будет расти просто с ростом аудитории Интернета. Поэтому характерной чертой высоконагруженных систем является не просто большое количество пользователей, но и &lt;em&gt;позитивная динамика&lt;/em&gt; количества пользователей.&lt;/p&gt;

&lt;p&gt;В контексте реалий Web 2.0 растущее количество пользователей может привести к тому, что &lt;em&gt;такую же позитивную динамику вы будете иметь и по данным&lt;/em&gt;. Поэтому в контексте высоконагруженных систем корректней говорить не о &lt;em&gt;большом&lt;/em&gt;, а о &lt;em&gt;растущем&lt;/em&gt; количестве пользователей и данных.&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;Интерактивность&lt;/h3&gt;
&lt;p&gt;И тут мы подходим к своеобразной финальной ноте в аккорде качеств highload систем, если позволите так выразиться. Интерактивность – одно из основополагающих качеств высоконагруженной системы. Интерактивность подразумевает, что пользователь после того как послал запрос сидит и ждет ответа, а люди как известно ждать не любят. При этом большинство Интернет-приложений о которых мы говорим не являются критическими важными в жизни людей. Twitter, Flickr, Facebook и т.д. это все круто конечно, но если они будут отвечать непомерно долго, я найду чем занятся еще. Наша жизнь от них не зависит (прогрессирующие формы задротства у некоторых особо аддиктивных индивидов не в счет), а это значит что эти приложения должны занимать минимум нашего времени. То есть отвечать за приемлимое время. Это контрастирует, например, с системами пакетной обработки данных, в которых время ответа системы вторично.&lt;/p&gt;

&lt;p&gt;Из этого правила безусловно есть исключения. Представьте что вы только что совершили покупку в Интернете сообщив свою платежную информацию третьим лицам. Скорее всего вы дождетесь ответа системы, даже если она будет отвечать дольше минуты. Но как известно исключение из правила лишний раз подверждает само правило.&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;Управление ресурсами&lt;/h2&gt;
&lt;p&gt;Качество интерактивности очень важно для понимания сути высоконагруженных приложений, потому что по вышеобозначенным причинам разрабатывая такую систему вы должны быть уверены вот в чем:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Каждый раз когда приложение получает очередной запрос, у него  должно быть достаточно свободных ресурсов (CPU, память, диск, сеть) для обработки запроса за приемлимое время.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Возможно это и звучит тривиально, но именно данное требование приводит нас к основному посылу данной заметки:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Контроль за ресурсами является неотъемлимой частью работы с высоконагруженным проектом.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Необходимо также учитывать тот факт, что из-за позитивной динамики &lt;em&gt;свободных ресурсов становится меньше с течением времени&lt;/em&gt;. В этом заключается &amp;ldquo;парадокс&amp;rdquo; высоконагруженных систем. Если вы возьмете высоконагруженный проект и заморозите его разработку (отправите всех разработчиков в бессрочный отпуск), то &lt;em&gt;рано или поздно он перестанет работать&lt;/em&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Высоконагруженная система – это интерактивная распределенная система которая требует постоянного контроля за собственными ресурсами. В противном случае она перестает работать.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Это противоречит обывательскому опыту. Как может само по себе поломаться то, чего не меняли? У программного кода нет срока годности. Причина в том, что со временем системе просто перестанет хватать ресурсов. А нехватка ресурсов провоцируется факторами, часть из которых мы уже рассмотрели:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;рост аудитории;&lt;/li&gt;
  &lt;li&gt;рост объема данных;&lt;/li&gt;
  &lt;li&gt;изменения паттернов поведения аудитории, в том числе и сезонные.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Если посмотреть темы докладов на конференциях посвященных тематике разработки высоконагруженных систем (например, тот же &lt;a href=&quot;http://highload.ru/&quot;&gt;highload&lt;/a&gt;), то большинство тем с которыми выступают докладчики можно свести к двум основополагающим направлениям:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;как решать существующие задачи используя меньше ресурсов (практически все NoSQL БД, неблокирующий I/O, оптимизация и тюнинг);&lt;/li&gt;
  &lt;li&gt;как имея больше ресурсов решать пропорционально больший объем задач (message queueing, распределенные вычисления, распределенные БД, параллелизм).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Эту дихотомию я уже затрагивал ранее в заметке &lt;a href=&quot;http://bazhenov.me/blog/2009/06/28/performance-versus-scalability.html&quot;&gt;Performance vs. Scalability&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Фактически речь на таких конференциях идет в основном о различных способах адекватного управления аппаратными ресурсами в контексте баз данных, языков программирования, операционных систем, алгоритмов, моделей ввода/вывода, вычислительных парадигм и т.д.&lt;/p&gt;

&lt;p&gt;Просто подумайте над этим. Большая часть пропогандируемых в настоящее время баз данных под эгидой NoSQL, не предоставляет качественно новых возможностей для разработчиков. Реляционная модель позволяет относительно легко все это реализовать не выходя за рамки одной парадигмы. В этом, я полагаю, и заключается одна из причин почему реляционки приобрели такую популярность и до сих остаются самым распространенным типом БД.
Так называемые, пост-реляционные базы данных не являются инструментом для решения качественно новых задач, всего лишь инструментом для более эффективного решения существующих. Именно важность эффективной траты ресурсов стала катализатором популярности NoSQL тематики.&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;Высоконагруженный проект – это Интернет приложение&lt;/h2&gt;
&lt;p&gt;Если исходить из того что неотъемлемой частью высоконагруженного проекта является постоянный рост данных и аудитории, то становится понятно почему высоконагруженные проекты – это поголовно Интернет приложения.&lt;/p&gt;

&lt;p&gt;В реальной жизни всегда есть некий предел, который не позволяет использовать систему все возрастающему количеству людей. В том же метрополитене человеку требуется некоторое время, чтобы пройти через турникет. Исходя из этого времени, а также общего количества турникетов можно достаточно точно расчитать верхний предел возможной нагрузки. Выглядит очень невероятным чтобы за секунду через один турникет могло пройти 10 человек.&lt;/p&gt;

&lt;p&gt;В сфере High Performance Computations приложения могут выполнять просто гигансткое количество операций в единицу времени. Больше чем любое Интернет-приложение. Но это количество зависит только от объема входных данных, а также алгоритма обработки (например, от точности моделирования, если речь идет о моделировании динамических систем). Тяжело придумать причину почему нагрузка на такую систему может вырасти сама по себе без вмешательства персонала ее сопровождающего.&lt;/p&gt;

&lt;p&gt;Похоже, что Интернет-приложения это единственная сфера в которой нагрузка есть переменная не имеющая верхнего предела.&lt;/p&gt;

&lt;h2 id=&quot;highload-&quot;&gt;Работая в Highload проекте&lt;/h2&gt;
&lt;p&gt;Но не стоит возводить данный тип проектов на какой-то особый пьедестал. Highload проект это в первую очередь такой же самый проект как и все остальные. Проект в котором бывают и гонки за фичами и deadline&amp;rsquo;ы и сложности межличностных отношений и все прочие &amp;ldquo;прелести&amp;rdquo; процесса разработки ПО. Но говоря о &amp;ldquo;высоконагруженной составляющей&amp;rdquo; проекта, работа над ней сводится к тому, что постоянно приходится искать ответы на ресурсно-ориентированные вопросы:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;какие bottleneck&amp;rsquo;и есть в системе по ресурсам и как их устранить?&lt;/li&gt;
  &lt;li&gt;каков запас системы по ресурсам учитывая естественный рост аудитории/данных?&lt;/li&gt;
  &lt;li&gt;что делать при нехватке того или иного ресурса? (например, можно за счет RAM сэкономить CPU).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Не удивительно что в такого рода проектах гигантское значение имеет система мониторинга. Она предоставляет массу информации для ответа на такого рода вопросы. Сопровождать и развивать высоконагруженный проект без мониторинга хотя бы основных метрик по всему серверному парку это безрассудство.&lt;/p&gt;

&lt;p&gt;Это приводит нас к cписку первостепенных задач которые стоят перед разработчиками в контексте высокой нагрузки:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;создание инфраструктуры предоставляющей качественную обратную связь по утилизации аппаратных ресурсов системы (мониторинг, self-аудит приложений);&lt;/li&gt;
  &lt;li&gt;определение звеньев системы нуждающихся в масштабировании в ближайшем времени и выбор стратегии масштабирования этих звеньев; &lt;/li&gt;
  &lt;li&gt;определение toolbox&amp;rsquo;а позволяющего решать типовые задачи эффективно по аппаратным ресурсам (базы данных, очереди сообщений, языки программирования, библиотеки и т.д.).&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-7&quot;&gt;В состоянии гонки&lt;/h2&gt;
&lt;p&gt;У вас как у инженера нет прямого влияния на количество пользователей и есть опосредованое влияние на объемы данных. В конце концов, чем больше данных и чем шире аудитория, тем лучше для бизнеса. Больше пользователей – больше возможностей для монетизации. Больше данных – больше конкурентное преимущество, а так же потенциально более высокие темпы роста проекта. Необходимо смирится с непрерывным ростом этих двух метрик.&lt;/p&gt;

&lt;p&gt;Что же остается? Не так много на самом деле. Сделать так чтобы возможности системы были всегда на шаг впереди ее потребностей.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:ref-metro-stat&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://www.mosmetro.ru/documents/11931/2010.pdf&quot;&gt;Московский Метрополитен 2010: Основные показатели работы метрополитена&lt;/a&gt;&lt;a href=&quot;#fnref:ref-metro-stat&quot; rel=&quot;reference&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:ref-stackoverflow-stat&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://msug.vn.ua/Posts/Details/4149&quot;&gt;Microsoft User Group Community: Немного статистики от StackOverflow за 2010 год&lt;/a&gt;&lt;a href=&quot;#fnref:ref-stackoverflow-stat&quot; rel=&quot;reference&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel> 
</rss>